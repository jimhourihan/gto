\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename gto.info
@settitle GTO File Format, Protocols, and Utilities
@setchapternewpage off
@c %**end of header

@tex
\global\emergencystretch = .9\hsize
@end tex

@ifinfo
This file documents release version 3.4 of the "GTO" File Format,
Protocols, and Utilities.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).
@end ignore

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
@end ifinfo
     
@c  This title page illustrates only one of the
@c  two methods of forming a title page.
     
@titlepage
@title GTO: The Kitchen Sink of Data
@subtitle File Format, Protocols, and Utilities.
@author Jim Hourihan, Tweak Films
     
@c  The following two commands
@c  start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2002-2007 Tweak Films. All rights reserved.
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
     
@end titlepage

@contents

@c -------------------------------------
@ifnottex
@node Top, Copying, (dir), (dir)
@top GTO File Format
     
This document describes the GTO file format, protocols, and
utilities. 

Copyright @copyright{} 2002-2007 Tweak Films. All rights reserved.
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

This document applies to release version 3.4 of the file format.
@end ifnottex

@menu
* Copying::                 GTO licensing terms (with Exceptions).
* Installation::            Compiling and Installing.
* Overview::                Uses for the GTO format.
* Binary Format::           Layout of Binary Files.
* Text Format::             Syntax of Text Files.
* Types::                   Types of Property Data That Can be Stored.
* Interpretation Strings::  Indicating Intended Use of Property Data.
* Object Protocols::        How to Interpret the Data.
* Names::                   Naming Convensions.
* Issues::                  Problems and Questionable Aspects of the Format.
* Extending::               Extending Protocols or the File Format.
* Library::                 Reading and Writing Using the C++ Library.
* Module::                  Reading and Writing Using the Python Module.
* Utilities::               Utility Programs and Plug-ins.
* Changes::                 Changes Between Versions.
* Reference::               Index of Functions, Types, and Variables.
@end menu

@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------
     
@node Copying, Installation, Top, Top
@unnumbered GNU LESSER GENERAL PUBLIC LICENSE and GTO EXCEPTIONS
@center Version 2.1, February 1999

@display
Copyright @copyright{} 1991, 1999 Free Software Foundation, Inc.  59
Temple Place, Suite 330, Boston, MA 02111-1307 USA

Everyone is permitted to copy and distribute verbatim copies of this
license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
as the successor of the GNU Library Public License, version 2, hence
the version number 2.1.]

@end display

@heading Exceptions to the LGPL for GTO (Nov 2007)

The GTO library and included programs are provided under the terms of
the GNU Library General Public License (LGPL) as put forth below with
the following exceptions (derived from the FLTK LGPL exceptions):

@enumerate 
@item Modifications to the GTO configure script, config header file, and makefiles by
themselves to support a specific platform do not constitute a modified
or derivative work.
   
The authors do request that such modifications be contributed to the GTO
project.
   
@item Static linking of applications or shared libraries to the GTO
library does not constitute a derivative work and does not require the
author to provide source code for the application or library, use the
shared GTO libraries, or link their applications or shared library
against a user-supplied version of GTO.
   
If you link the application or shared library to a modified version of
GTO , then the changes to GTO must be provided under the terms of the
LGPL in sections 1, 2, and 4.
   
@item You do not have to provide a copy of the GTO license with programs that are linked
to the GTO library, nor do you have to identify the GTO license in your
program or documentation as required by section 6 of the LGPL.
   
However, programs must still identify their use of GTO. The following
example statement can be included in user documentation to satisfy this
requirement:
   
[program/shared library] is based in part on the work of the GTO
project.
@end enumerate

@heading Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

@center GNU LESSER GENERAL PUBLIC LICENSE
@center TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

 

@enumerate 0
@item This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

@item You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

@item You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

@enumerate a
@item The modified work must itself be a software library.

@item You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

@item You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

@item If a facility in the modified Library refers to a function or a 
table of data to be supplied by an application program that uses
the facility, other than as an argument passed when the facility is
invoked, then you must make a good faith effort to ensure that, in the
event an application does not supply such function or table, the
facility still operates, and performs whatever part of its purpose
remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)
@end enumerate

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

@item You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

@item You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

@item A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

@item As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

@enumerate a
@item Accompany the work with the complete corresponding
machine-readable source code for the Library including whatever
changes were used in the work (which must be distributed under
Sections 1 and 2 above); and, if the work is an executable linked with
the Library, with the complete machine-readable "work that uses the
Library", as object code and/or source code, so that the user can
modify the Library and then relink to produce a modified executable
containing the modified Library.  (It is understood that the user who
changes the contents of definitions files in the Library will not
necessarily be able to recompile the application to use the modified
definitions.)

@item Use a suitable shared library mechanism for linking with the
Library.  A suitable mechanism is one that (1) uses at run time a copy
of the library already present on the user's computer system, rather
than copying library functions into the executable, and (2) will
operate properly with a modified version of the library, if the user
installs one, as long as the modified version is interface-compatible
with the version that the work was made with.

@item Accompany the work with a written offer, valid for at
least three years, to give the same user the materials specified in
Subsection 6a, above, for a charge no more than the cost of performing
this distribution.

@item If distribution of the work is made by offering access to copy
from a designated place, offer equivalent access to copy the above
specified materials from the same place.

@item Verify that the user has already received a copy of these
materials or that you have already sent this user a copy.

@end enumerate

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

@item You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

@enumerate a
@item Accompany the combined library with a copy of the same work
based on the Library, uncombined with any other library facilities.
This must be distributed under the terms of the Sections above.

@item Give prominent notice with the combined library of the fact
that part of it is a work based on the Library, and explaining where
to find the accompanying uncombined form of the same work.

@end enumerate

@item You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

@item You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

@item Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

@item If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

@item If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

@item The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

@item If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

@center			    NO WARRANTY

@item BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

@item IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

@end enumerate
@center		     END OF TERMS AND CONDITIONS

@c ----------------------------------------------------------------------
@node Installation, Overview, Copying, Top
@chapter Installation

The GTO source code is built using the GNU autotools. When you unpack
the source code, the following should successfully build and install
the binaries and library. Note that you may need to become root for
@command{make install} to succeed.

@example
    sh> cd gto-x.x
    sh> ./configure
    sh> make
    sh> make install
@end example

If you have Maya installed, the Maya I/O plugin can be compiled. You
can give the @option{--enable-maya-plugin} argument to the configure
script to have the plugin built. See the INSTALL file at the top of
the source code tree for more information on using configure.

If you have zlib installed, configure will automatically assume you
want native compression support for the Reader/Writer library.

@menu

Operating system specific instructions

* Linux::                  GNU/Linux
* OSX::                    Mac OS X
* Windows::                Microsoft Windows 2000/XP/Vista
@end menu

@c ----------------------------------------------------------------------
@node Linux, OSX, Installation, Installation
@section GNU/Linux

The Maya plugin almost certainly requires a specific compiler for
GNU/Linux installation with Maya 4.x or 3.x. On versions of Red Hat
Linux 7.x the default compiler should be used; this should be gcc
2.96. On later versions of Red Hat, 8.x and 9.x, you will need to
install the following prior to Maya 7:

@example 
    compat-gcc-7.3-2.96.110.i386.rpm
    compat-gcc-c++-7.3-2.96.110.i386.rpm
    compat-libstdc++-7.3-2.96.110.i386.rpm
    compat-libstdc++-devel-7.3-2.96.110.i386.rpm
@end example

In that case, the compiler will be called gcc296 and you will need
to do this before running configure:

@example
    sh> CC=gcc296
    sh> export CC
    sh> CXX=g++296
    sh> export CXX
@end example

If you are using Maya 5.x you will need to use gcc 3.1 or greater to
compile the plugin. In that case no compatibility rpms are
necessary. Alias recommends using gcc 3.2.

For Maya 6.x, 7.x use gcc 3.3.2 or a newer 3.3.

For Maya 8.x use gcc 4.0.2. You may need to compile your own version of
the compiler even if the same version is shipped with the OS. See the
Autodesk documentation regarding Maya 8.x plugins.

If you are not using the Maya plugin, or you want to use the GTO
library, but using a different compiler, you may need to run the build
and installation process more than once with different compiler
settings. 

On non Red Hat or home grown GNU/Linux systems, the library and binary
tools should build and install using the normal proceedure. Here at
Tweak, we typically build the library and binary tools using gcc 3.1
or greater.

@c ----------------------------------------------------------------------
@node OSX, Windows, Linux, Installation
@section Mac OS X

The GTO library and binaries should build normally on OS X if you have
installed the developer tools. You should have a version of the
developer tools that uses gcc 3.1 or better.

The Maya plugin on Mac OS X requires the use of CodeWarrior to compile
a CFM shared object for Maya versions 4.x and 5.x. In addition, for
the 4.x versions, you will need to hack the CodeWarrior system header
files to get the build to work. We have not had much success in
getting the plugin to compile for OS X since the header munging
instructions did not work for us. However, there is no reason to
suspect that givin the proper CodeWarrior version and modifications
that it would not compile.

For Maya 6.x and greater, you can use the installed version of gcc
since Maya is now a Mach-O binary.

For Maya 8.x on Intel and PPC with 10.4.X use the installed gcc 4
compiler and follow the instructions in the Maya developers
docs. Compiling for Maya 8.x is much easier on OS X than with previous
versions. Check for precompiled plugins for OS X intel at the tweak
website. 

@c ----------------------------------------------------------------------
@node Windows,  , OSX, Installation
@section Microsoft Windows 2000/XP/Vista

In theory, you can compile the library and binary tools using the
Cygwin environment and gcc 3.x but we have not tested it.

Maya on Windows 2000 requires the use of Visual C++ 6.x. This compiler
does not come close to complying with the ANSI C++ standard and requires
many work arounds to compile the GTO library and Maya plugin. Because of
this, the library and tools are currently unsupported on Windows.

Your mileage may vary for other Windows compilers.

@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------
     
@node Overview, Binary Format, Installation, Top
@chapter Overview

Historically, GTO format's primary usage is storage of static geometric
data. As such, the types of data you might find in a GTO file are things like
polygonal meshes, various types of subdivision surfaces, NURBS or UBS
surfaces, coordinate systems, hierarchies of objects, material
bindings, and even images.

In our facility -- Tweak Films -- geometric data in GTO files is
rendered directly by entropy (a prman compatible rib renderer) and used
for modeling and 3D paint. We also use the GTO format in place of the
venerable and yet nasty PDB file format for particles.

As of GTO version 3.2, the format is being used for data not related to
geometric data (e.g., pixel data) and animation curve data is now part
of the format spec -- so that data is no longer ``static'' as it has
been in the past.

From a historic point of view, the GTO file format is most closely
related to the original inventor file format, the Stanford PLY format
and the PDB particle format. Like the Wavefont PDB file format, there
are a limited number of simple GTO data types (float, int, string,
boolean). Like the inventor file format, a GTO can hold an entire
transformation hierarchy including geometric leaf nodes. Like the PLY
format, the GTO format can contain an arbitrary amount of data per
primitive. Most importantly however, the GTO file format is intended to
be very OBJ-like; its relatively easy to read and write and easy to
ignore data you don't want or know about.

GTO files can be either binary or text files. Binary files are the 
preferred format for large data sets. The GTO text format is intended 
to be human readable/editable; the syntax is simple and concise.
The text format is useful when storing ``bag of parameters'' files
and similar data.

We provide code for both the binary and text formats to give 
implementors a head start. The binary file is either big or little endian 
on disk, but should be readable on any platform.

The GTO reader we provide can be use libz, so it can read and write
compressed files natively. We find that compressed GTO files created by 
most 3D programs are approximately 60% leaner than uncompressed files.

GTO files conceptually contain @emph{objects} which are composed of
@emph{components}. Components are further composed of @emph{properties}. 
A property contains an array of one of the predefined data types with 
a specified width. For example, you might have an object which looks 
something like this:

@example

    Object "cube"
        Component "points"
            Property float[3][8] "position"
            Property float[1][8] "mass"
        Component "elements"
            Property byte[1][8] "type"
            Property short[1][8] "size"
        Component "indices"
            Property int[1][32] "vertex"
@end example

Using the terminology above, the object ``cube'' contains five
properties: @strong{position}, @strong{mass}, @strong{type}, @strong{size}, and
@strong{vertex}. The @strong{points} component describes the points that make up
the cube vertices. Each point has a position and mass stored in
properties of the same name. The position property data is composed of
eight float[3] data items (or 8 3D points). The @strong{mass} property is
composed of a 8 scalar floating point values (one for each point).

The @strong{elements} component contains two properties. @strong{type} indicates
the type of the element (for example, triangle, quad, or triangle
strip). In this case the elements might all be quads. @strong{size}
indicates the number of vertices in each of the eight faces (elements)
of the cube -- (4 for a cube). The @strong{vertex} property of the
@strong{indices} component contains the actual indices: 4 per face for a
total of 32.

Of course you could store much more data with the cube object if you
wanted to. For example, if you wanted velocity or color per point,
this would be another property in the @strong{points} component. 

The meaning of this data is another story altogether. Its all handled
by protocol. One application may store things in the GTO file that
another application has no method of interpreting even though it can
read that data and modify it. In the example above, you need to know
to expect that polygonal data is stored in the given properties. The
same data could be stored with different property names and a more
complex layout. (The ``polygon'' protocol described later in this
document is different and more involved than the above example.)

@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------

@node Binary Format, Text Format, Overview, Top
@chapter Binary Format

The GTO file has six major sections which appear in the following
order. 

@enumerate

@item
@strong{Header} (Gto::Header). The header structure contains the GTO
magic number (used to determine endianness), the version of the GTO
specification that the file was written as, and the number of top
level objects in the file. There is one instance of a header in the
file. Finally, the header indicates how many strings are in the string
table.

@example

    Magic = 0x0000029f;
    Cigam = 0x9f020000; // means the file is opposite endianess

    struct Header
    @{
        uint32      magic;
        uint32      numStrings;
        uint32      numObjects;
        uint32      version;
        uint32      flags;              // reserved;
    @};
@end example

@item
@strong{String Table}. After the header, null terminated strings are
written in the file. The order of these strings is important. All
names and string properties store indices into the string table
instead of actual strings. In order to read the file properly, the
string table must be available until the file is completely
read. (Unless you don't care about any strings!)

The index number refers the string number in the table not its byte
offset. So the string index 9 (for example) refers to the 10th string
in the table (string index 0 is the first string in the table).

@item
@strong{ObjectHeader} (Gto::ObjectHeader). The object header indicates
what kind of protocol to use to interpret it, the object name and the
number of components. (More on the @strong{object} protocol
later). The name -- like all strings in the GTO file -- is stored as a
string table entry. If the file header indicated N objects in the
file, there will be N ObjectHeaders.

@example

    struct ObjectHeader
    @{
        uint32      name;               // a string table index
        uint32      protocolName;       // a string table index
        uint32      protocolVersion;
        uint32      numComponents;
        uint32      pad;                // unused
    @};

@end example


@item
@strong{ComponentHeader} (Gto::ComponentHeader). Like the
ObjectHeaders the ComponentHeaders will appear together for all
objects in order. The component header indicates the number of
properties in the component and the name of the component.

@example

    enum ComponentFlags
    @{
        Transposed  = 1 << 0,
        Matrix      = 1 << 1,
    @};

    struct ComponentHeader
    @{
        uint32      name;               // a string table index
        uint32      numProperties;
        uint32      flags;
        uint32      interpretation;     // a string table index
        uint32      pad;                // unused
    @};

@end example

@item
@strong{PropertyHeader} (Gto::PropertyHeader). The PropertyHeaders,
like the object and component headers, appear en masse in the
file. The PropertyHeader contains the name, size, type, and dimension
of the property.

@example

    enum DataType
    @{
        Int,                // int32
        Float,              // float32
        Double,             // float64
        Half,               // float16
        String,             // string table indices
        Boolean,            // bit
        Short,              // uint16
        Byte                // uint8
    @};


    struct PropertyHeader
    @{
        uint32      name;           // string table index
        uint32      size;
        uint32      type;           // DataType enum value
        uint32      width;
        uint32      interpretation; // string table index
        uint32      pad;            // unused
    @};

@end example

@item
@strong{Data}. The last section of the file contains all of the
property data. The beginning and end of a properties data are not
marked. The size must be consistant with the description of the
property used in the PropertyHeader.

@end enumerate

In (Text) diagram form the file looks something like this:

@example

    +------------------+
    | File Header      |
    +------------------+
    | String Table     |
    +------------------+
    | Object Header    |
    |       .          |
    |       .          |
    |       .          |
    +------------------+
    | Component Header |
    |       .          |
    |       .          |
    |       .          |
    +------------------+
    | Property Header  |
    |       .          |
    |       .          |
    |       .          |
    +------------------+
    | Property Data    |
    |       .          |
    |       .          |
    |       .          |
    +------------------+


@end example

@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------
     
@node Text Format, Types, Binary Format, Top
@chapter Text Format

As of version 4, GTO has a text representation in addition to the binary
representation. The text representation is designed for human use; it is
intended to be easy to modify or create from scratch in a text editor. It 
is not intended to compete with XML formats (which are typically only human 
readable in theory) nor is it intended to be used in place of the binary
format which is much faster and more economical for storage of large data 
sets.

@menu
* Example Text File::           Example of a Cube Stored as a Text GTO
* Strings in a Text File::      How Strings are Used in a Text GTO
* The Size of a Property::      Specifying Property Size
* Value Brackets::              How Values are Specified 
* Run Length Encoding of Values::   Encoding Redundancy
* Syntax::                      Syntax Reference
@end menu

@node Example Text File, Strings in a Text File, Text Format, Text Format
@section Example of a Cube Stored as a Text GTO

Here's the example from the overview section: a cube stored using the 
``polygon'' protocol:

@example
    GTOa (4)

    # this is a comment

    cube : polygon (2)
    @{
        points
        @{
            float[3] position = [ [ -2.5 2.5 2.5 ] 
                                  [ -2.5 -2.5 2.5 ] 
                                  [ 2.5 -2.5 2.5 ] 
                                  [ 2.5 2.5 2.5 ] 
                                  [ -2.5 2.5 -2.5 ] 
                                  [ -2.5 -2.5 -2.5 ] 
                                  [ 2.5 -2.5 -2.5 ] 
                                  [ 2.5 2.5 -2.5 ] ]

            float mass = [ 1 1 1 1 1 1 1 1 ]
        @}

        elements
        @{
            byte type = [ 2 2 2 2 2 2 ]
            short size = [ 4 4 4 4 4 4 ]
        @}

        indices
        @{
            int vertex = [ 0 1 2 3 
                           7 6 5 4 
                           3 2 6 7 
                           4 0 3 7 
                           4 5 1 0 
                           1 5 6 2 ]
        @}
    @}
@end example

The first line of the file is an identifier to tell the parser what variety 
of GTO file it is: in this case @code{GTOa} which indicates a plain ASCII 
text file. Currently the parser can only handle ASCII encoding; a 
forthcoming version will allow UTF-8.

Objects are declared using the syntax:

@example
    OBJECTNAME [ : PROTOCOL [ (PROTOCOL_VERSION) ] ]
    @{
        ... object contents ...
    @}
@end example

The brackets enclose optional syntax. So the @code{PROTOCOL_VERSION} 
(including the parens) is optional. The @code{PROTOCOL} is also optional; 
if omitted (along with the colon) the protocol defaults to @strong{object}. 
In the example, ``cube'' is the name of the object and ``polygon'' is the 
name of the protocol--the protocol version is @code{2}.
    
Components must be declared inside the object brackets. The brackets denote
a @emph{namespace} which is either an object namespace or a component namespace.
Component namespaces must always be declared inside of an object namespace.
Object namespaces can only appear at the top level of the file; in other words,
objects cannot be inside another namespace.

Components are declared like this:

@example
    COMPONENTNAME [as INTERPRETATION]
    @{
        ... component contents ...
    @}
@end example

The @code{INTERPRETATION} can be any string. Properties can be declared 
inside of the component namespace. The property declaration is the most
flexible; since some aspects of the property (like its size) can be determined 
by the parser from the property data, you can omit them.

The property syntax in its most general form is:

@example
    TYPE[WIDTH][SIZE] PROPERTYNAME as INTERPRETATION = @emph{values} ...
@end example

The brackets around @code{WIDTH} and @code{SIZE} are literal in this case;
they actually appear in the file. As you can see from the example, some of
the property declaration syntax is optional. The @code{SIZE} can usually
be determined from the values so it may be omitted. The @code{WIDTH} is 
assumed to be @code{1} if it is omitted. The @code{as INTERPRETATION} 
section of the declaration may also be omitted. 

What cannot be omitted is the @code{TYPE}, @code{PROPERTYNAME}, and the
assignment of values.

@node Strings in a Text File, Value Brackets, Example Text File, Text Format
@section How Strings are Handled in the Text Format

With the exception of keywords and type names, any string in the text
GTO file can be either be quoted or non-quoted. Non-quoted strings are
restricted to strings which do not represent numbers. In addition, if a
string contains punctuation or whitespace, it must be quoted. For
example, if the name of the object in the cube example was ``four
dimensional time-cube'' it would have to be declared like this:

@example
    "four dimensional time-cube" : polygon
    @{
        ...
    @}
@end example

There is one additional exception: if a string is also a keyword or type 
name, it must be quoted. For example, here's an exceptional property
declaration:

@example
    int "int" as "as" = 1
@end example

In this case the quoted string ``int'' is being used as the property
name, but because it is also the name of a GTO type, it must be quoted.
The string ``as'' is being used as an interpretation string and must
be quoted because ``as'' is also a keyword in the the GTO file.

When in doubt quote.

@node Value Brackets, The Size of a Property, Strings in a Text File, Text Format
@section Value Brackets

Generally, a property value and elements of the value are enclosed 
in brackets:

@example
    TYPE[WIDTH] PROPERTYNAME = [ [a b ...] [d e ...] ... ]
@end example

In this documentation, the @emph{value} of a property is everything
to the right of the ``='' and an @emph{element} is a fixed size 
collection of numbers or strings. The @emph{size} of a property is
the number of elements in its value. So in the example above,
the @code{[a b ...]} portion of the syntax is an @emph{element}.

Bracketing the property value is optional in one circumstance: when the 
number of elements in the property value is one. For example, these 
declarations are equivalent:

@example
    int foo = 1
    int foo = [1]
@end example

If the width of the type is not one (elements are not scalar), then brackets 
must be put around each element of the property. If the size is one but the
width is not one, then the enclosing brackets are still optional:

@example
    int[2] foo = [1 2]
    int[2] foo = [ [1 2] ]
@end example

If however the size of the property is greater than one, the enclosing
value brackets are required:

@example
    # property of size 3
    int[2] foo = [ [1 2] [3 4] [5 6] ]
@end example

To declare a property with no value use empty brackets:

@example
    int foo = []
@end example

@node The Size of a Property, Run Length Encoding of Values, Value Brackets, Text Format
@section The Size of a Property

The size of a property can be declared as part of its type declaration:

@example
    int[1][4] foo = [1 2 3 4]
@end example

In this case, ``foo'' contains four scalar elements. Because the size
was specified, the following would be a syntax error:

@example
    int[1][4] foo = [1 2 3 4 5]
@end example

The parser would complain because five elements were supplied eventhough
the property was declared as having only four. If no size is specified
than the parser will determine the size from the number of elements in
the value:

@example
    int[1] foo = [1 2 3 4 5]
@end example

So in this case ``foo'' has five elements. Note that in order to declare
the size specifically, you must also declare the element width -- even if
the width is one. In the last example, because we did not specify the
size, the declaration could also have been:

@example
    int foo = [1 2 3 4 5]
@end example

In this case it is understood that the type is actually @code{int[1][5]}.

@node Run Length Encoding of Values, Syntax, The Size of a Property, Text Format
@section Run Length Encoding of Values

In some cases, a value will contain many copies of an element. There is
a special syntax for these cases; you can use an ellipsis to indicate
that all remaining elements are identical. The ellipsis can only appear
directly before the final bracket character.

There is one restriction when using this syntax: the type of the
property value must be completely specified (including the size of the
property) and the value must be enclosed in brackets. For example:

@example
    int[1][100] mass = [1 ...]
@end example

The ellipsis is literal (its actually in the file as three dot characters) 
The property ``mass'' will be one for all 100 elements. If the element has
a width greater than one:

@example
    float[3][100] velocity = [ [0 0 0] ... ]
@end example

The ellipsis is used in place of an element. The following will 
@emph{not} work:

@example
    float[3][100] velocity = [ [0 ...] ... ]
@end example

The intention here is to make all of the velocity elements @code{[0 0 0]}.
However, this syntax is not correct and will produce a parsing error.

@node Syntax,  , Run Length Encoding of Values, Text Format
@section Syntax Reference

The grammar for the text GTO file. @emph{INT} is an integer constant.
@emph{FLOAT} is a floating point constant, with a possible exponent
part. @emph{STRING} is either a quoted or non-quoted string. All other
values are literal. Double quoted strings are keywords.

@example
    file::
        "GTOa" object_list 
        "GTOa" ( @emph{INT} ) object_list 

    object_list::
        object 
        object_list object

    object::
        @emph{STRING} @{ component_list @}
        @emph{STRING} : @emph{STRING} @{ component_list @}
        @emph{STRING} : @emph{STRING} ( @emph{INT} ) @{ component_list @}

    component_list::
        component 
        component_list component

    interp_string_opt::
        @emph{nothing}
        "as" @emph{STRING}

    component::
        @emph{STRING} interp_string_opt @{ property_list @}

    property_list::
        property 
        property_list property

    property::
        type @emph{STRING} interp_string_opt = atomic_value
        type @emph{STRING} interp_string_opt = [ complex_element_list ]

    type::
        basic_type
        basic_type [ @emph{INT} ]
        basic_type [ @emph{INT} ] [ @emph{INT} ]

    basic_type::
        "float" "int" "string" "short" "byte" "half" 
        "bool" "double"

    complex_element_list::
        @emph{nothing}
        element_list 
        element_list "..." 

    element_list::
        element 
        element_list element

    element::
        atomic_value
        [ atomic_value_list ]

    atomic_value_list::
        string_value_list 
        numeric_value_list

    atomic_value::
        string_value 
        numeric_value

    string_value_list::
        string_value 
        string_value_list string_value 

    string_value::
        @emph{STRING}

    numeric_value_list::
        numeric_value 
        numeric_value_list numeric_value

    numeric_value::
        float_num 
        int_num

    float_num::
        @emph{FLOAT} 
        - @emph{FLOAT}

    int_num::
        @emph{INT}
        - @emph{INT}

@end example


@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------
     
@node    Types, Interpretation Strings, Text Format, Top
@chapter Types of Property Data.

The GTO format pre-defines a small number of data types that can be
stored as properties. The currently defined types are:

@deftp {Property Type} double
64 bit IEEE floating point.
@end deftp

@deftp {Property Type} float
32 bit IEEE floating point.
@end deftp

@deftp {Property Type} half
16 bit ``IEEE floating point'' number as defined by ILM's OpenEXR
Imath library half data type. You can find links to source code and
documentation at @url{http://www.openexr.org/}.
@end deftp

@deftp {Property Type} int
32 bit signed integer.
@end deftp

@deftp {Property Type} short
16 bit unsigned integer.
@end deftp

@deftp {Property Type} byte
8 bit unsigned integer (char).
@end deftp

@deftp {Property Type} bool
Bit or bit vector. Not currently implemented.
@end deftp

@deftp {Property Type} string
The string type is stored as a 32 bit integer index into the GTO
file's string table. So storing a lot of strings (especially if there
is a lot of redundancy) is reasonably cheap. All strings in the GTO
file are stored in this manner.
@end deftp

Each of these data types can be made into a vector of that type. For
example the float data type can be made into a point @code{float[3]}
or a matrix @code{float[16]}. To store a scalar element the size of
the vector is 1.  (e.g. @code{float[1]}).

In this document, the types are all specified as 2 dimensional arrays
ala the C programming language. Here is a complete list of example
type forms:

@itemize @bullet
@item
@code{float[3]} - the float triple type.
@item
@code{float[1][1]} - a single floating point number.
@item
@code{float[3][]} - any number of float triples.
@item
@code{float[3][3]} - three float triples.
@item
@code{float[16][]} - any number of a 16 float (4x4 matrix) elements.

@end itemize

@c -------------------------------------------------------------------------

@node Interpretation Strings, Object Protocols, Types, Top
@chapter Interpretation Strings

Each property can have an additional string stored with it call the
``interpretation''. The intent is to allow applications to provide
specific information about the property. For example, a property of
type @code{float[4]} can be interpreted as a homogeneous 3D
coordinate, a quaternion, or an RGBA value. The interpretation field
can be used to distinguish between them.

Why not just make new primitive GTO types for these? The format's only
purpose is storage of data. By decoupling the interpretation of the
data from its storage, each application is allowed to make its own
policy while maintaining flexibility for simpler applications.

Here's a simple example of @command{gtoinfo} output of a file with an
image object in it created with @command{gtoimage}:

@example
    object "image" protocol "image" v1
      component "image"
        property string[1][1] "originalFile" interpret as "filename" 
        property string[1][1] "originalEncoding" interpret as "filetype" 
        property string[1][1] "type"
        property int[1][2] "size"
        property float[3][199168] "pixels" interpret as "RGB" 
@end example

The example illustrates two points: the interpretation string can be
used to better determine the data type of the property (as is the case
with the ``RGB'' string) and it can also be used to interpret the
usage (the ``filename''). 

Some of the stings will be application specific. Programs that
generically edit GTO files should attempt to preserve the
interpretation strings.

It is not an error to define the interpretation for a property as the
empty string -- in other words, unspecified. 

The following strings are not currently part of the format
specification but are used by the sample implementation. In a future
release we may make these ``official''. Its ok to have multiple space
seperated strings in the interpretation strings (e.g. ``4x4
row-major").

@deftp {Interpretation String} coordinate
The data can be of any width or type. For width @code{N} the data
represents a point in @code{N} dimensional space.
@end deftp

@deftp {Interpretation String} normal
The data can be of any width or type. For width @code{N} the data
represents a unit vector prependicular to an @code{N} dimensional
surface or in the case of @code{N} == 2, a curve.
@end deftp

@deftp {Interpretation String} 4x4
The width of the property data should be 16. The data is intended to
be interpreted as a 4x4 matrix. For example, the
@strong{object.globalMatrix} property of the @strong{Coordinate
System} protocol would be a ``4x4'' 
property.
@end deftp

@deftp {Interpretation String} 3x3
The width of the property data should be 9. The data is intended to
be interpreted as a 3x3 matrix. 
@end deftp

@deftp {Interpretation String} row-major
Indicates that matrix data is in row major ordering.
@end deftp

@deftp {Interpretation String} column-major
Indicates that matrix data is in column major ordering.
@end deftp

@deftp {Interpretation String} quaternion
The width of the property should be four. The data should be
interpreted as a quaternion. Presumably the type of a quaternion
property would be @code{float[4]} or @code{double[4]} since these are
the only types that make sense. The first element of the data is the
real part followed by the ``i'', ``j'', and ``k'' imaginary
components.
@end deftp

@deftp {Interpretation String} complex
The width of the property should be two. The data is interpreted as a
complex number with the first element being the real part and the
second element the imaginary part. 
@end deftp

@deftp {Interpretation String} indices
The data type should be an integral type. The property contains
indices. 
@end deftp

@deftp {Interpretation String} bbox
The data type should have an even width. The property contains
bounding boxes.
@end deftp

@deftp {Interpretation String} homogeneous 
The width of the property should be two or more. If the width is
three, then the data is a two dimensional homogeneous coordinate. If
the width is four, then the data is a three dimensional homogeneous
coordinate. So for data of width @code{N} the data represents a
homogeneous coordinate in @code{N-1} dimensions.
@end deftp

@deftp {Interpretation String} RGB
The width of the property should be three. The data represents a color
with red, green, and blue components.
@end deftp

@deftp {Interpretation String} BGR
The width of the property should be three. The data represents a color
with blue, green, and red components. (Reversed @code{RGB})
@end deftp

@deftp {Interpretation String} RGBA
The width of the property should be four. The data represents a color
(or pixel) with red, green, blue, and alpha components.
@end deftp

@deftp {Interpretation String} ABGR
The width of the property should be four. The data represents a color
(or pixel) with alpha, blue, green, and red components. (Reversed
@code{RGBA})
@end deftp

@deftp {Interpretation String} bezier
The property represents a 2D bezier curve for animation.  The type
should be a floting point type and the width six. Each element is a
key frame value.
@end deftp

@deftp {Interpretation String} weighted
In the case of bezier animation curves, the curve should be evaluated
with weighted tangents.
@end deftp

@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------

@node Object Protocols, Names, Interpretation Strings, Top
@chapter Object Protocols

The Object data interpretation is not defined by the GTO
format. However, there are currently some protocols in use that are
well defined and these are documented here. Caveat emptor: gto files
in the wild may contain more data than these protocols define, but
they presumably will obey the protocol if they indicate it by
name. It's also possible that some objects may obey more than one
protocol yet only indicate that they follow one. Unfortunately, some
protocols also specify optional components and properties in case all
of this was not confusing enough.

Protocols also have a version number. The version number is an
integer; there are no sub-versions. If there are significant changes
to a protocol, the version number should be bumped. The version number
is not meant as a method of making alternate protocols with the same
name. We have had to make three modifications to the protocols since
the file format was invented; one to the polygon protocol and one to
the transform protocol, and the introduction of a new protcol
(connections). The changes are documented in those sections.

In this document, properties are all named ``comp.prop'', where
``comp'' is the name of the component the property belongs to and
``prop'' is the name of the property. This is done to prevent
ambiguity when two different properties in different components but
with the same name exist. In the GTO file and when using the reader
library only the property name will appear.

There are two kinds of protocols: major and minor. Every object must
have a major protocol that's stored in the ObjectHeader -- this is the
main indicator of how to interpret the object data. In addition, the
object may also have several minor protocols. These indicate optional
data and how to interprete it. The next section describes how these
are stored in the file.

@menu

Major (Object) Protocols

* Object::                The Kitchen Sink of protocols.
* Coordinate Systems::    Coordinate System / Transforms.
* Particles::             Particles are easy -- supposedly.
* Strands::               Hair, Grass, lots of curves.
* NURBS Surfaces::        NURBS and fewer letter (UBS) surfaces.
* Polygonal Surfaces::    Polygons, in all their gory mess.
* Subdivision Surfaces::  Catmull-Clark and Loop surfaces.
* Image::                 Image Object.
* Material::              Material definition.
* Group::                 Object grouping.

* Inter-Object::          Object Relationship Information.

Minor Protocols

* Difference::            Difference Files.
* Sorted Shells::         Special ordering for Polygonal Surfaces.
* Channels::              Texture and other data mapped to surfaces, etc.
* Animation::             Animation curves and data streams.

@end menu

@c ----------------------------------------------------------------------

@node Object, Coordinate Systems, Object Protocols, Object Protocols
@section Object Protocol

The name of the protocol as it appears in the ObjectHeader is
``object'' version 1. The protocol does not require any other
protocols.  Here it is:

@deftypevr {Required Component} {} {object}
A container for properties which don't fit into other component
catagories well. A catch-all data ``per-object'' component.
@end deftypevr

@deftypevr {Optional Property} {float[16][1]} {object.globalMatrix}
The global world-space transform for the object.
@end deftypevr

@deftypevr {Optional Property} {float[6][1]} {object.boundingBox}
The global world-space bounding box for the object.
@end deftypevr

@deftypevr {Optional Property} {string[1][1]} {object.parent}
Name of this object's parent in a scene heirarchy.
@end deftypevr

@deftypevr {Optional Property} {string[1][1]} {object.name}
The name of the object. This name should be identical to the name in
the ObjectHeader.
@end deftypevr

@deftypevr {Optional Property} {string[1][]} {object.protocol}
Additional protocols. This property may contain the main protocol name
and any other minor protocols that the object adheres to. If a
protocol name appears in this property, the object must adhere to that
protocol. Its not an error for a program to output this property with
only the major protocol as its value; this is of course redundant
since the protocol name is required by the ObjectHeader. It is also
not an error for this property to exist but contain nothing.
@end deftypevr

@deftypevr {Optional Property} {int[1][]} {object.protocolVersion}
Additional protocol version numbers. This property may exist if the
@strong{object.protocol} property exists. Each entry in this property
corresponds to the same entry indexed in the @strong{object.protocol}
property. This property must contain the same number of elements that
the @strong{object.protocol} property does.
@end deftypevr

You may be asking why the @strong{object} protocol exists at all. The
name of an object is stored in the ObjectHeader in the file and in the
C++ library is passed to the reader code. The ``name'' property is
redundant right? Well yes. But some programs will output the name both
in the ObjectHeader and in an @strong{object} component as the
property ``name''.

The main point of this protocol is to define the @strong{object}
component. This component is meant to hold data that is ``per object''
and which doesn't really fit neatly into other components. The name is
one such case. The coordinate system protocol also defines properties
in the @strong{object} component and the minor protocols are
optionally stored here.

@c ----------------------------------------------------------------------

@node Coordinate Systems, Particles, Object, Object Protocols
@section Coordinate System Protocol

The name of the protocol as it appears in the ObjectHeader is
``transform'' version 3@footnote{In version 1, the transform protocol's
object.globalMatrix property used to be of type
@code{float[1][16]}. This was a mistake that has been corrected in
version 2.}. The protocol requires the @strong{object} protocol. Objects
which obey the @strong{transform} protocol will have global matrices and
possibly a parent.

@deftypevr {Required Component} {} {object}
From the "object" protocol.
@end deftypevr

@deftypevr {Required Property} {float[16][1]}  {object.globalMatrix}
A 4x4 matrix of floating point numbers. This matrix describes the
world matrix of the coordinate system.
@end deftypevr

@deftypevr {Optional Property} {string[1][1]}  {object.parent}
The name of an object to which this coordinate system is
parented. Presumably this object (if it appears in the gto file) will
also obey the @strong{transform} protocol. If this property does not
exist or the name is ``'' (the empty string) then the coordinate
system presumably is a root coordinate system.@footnote{In version 3
of the @strong{transform} protocol, the @strong{object.parent}
property is redundant and therefor deprecated. The
@strong{connection} protocol
handles the transformation hierarchy information and in a much more
elegant manner @xref{Inter-Object}.}
@end deftypevr

@c ----------------------------------------------------------------------

@node Particles, Strands, Coordinate Systems, Object Protocols
@section Particle Protocol

The name of the protocol as it appears in the ObjectHeader is
``particle'' version 1. The protocol may include the @strong{object} and
@strong{transform} protocols.

@deftypevr {Required Component} {} {points}
The points component is transposable. That means that all of its
properties are required to have the same number of elements. 
@end deftypevr

@deftypevr {Optional Property} {float[3][]} {points.position} 
@deftypevrx {Optional Property} {float[4][]} {points.position}
The position property is intended to hold the position of the particle
in its own coordinate system or world space if it has no coordinate
system. The element is either a 3D or 4D (homogeneous) point.
@end deftypevr

@deftypevr {Optional Property} {float[3][]} {points.velocity}
The velocity property -- if it exists -- should hold the velocity
vector per-point in the same coordinate system that the ``position''
property is in.
@end deftypevr

@deftypevr {Optional Property} {int[1][]}  {points.id}
The ``id'' property should it exist will @emph{always} be defined as
an integer per particle (or other integral type if it ever
changes). This number should be unique for each particle. Ideally,
multiple GTO files with a point that has the same ``id'' property for
a given particle animation @emph{should} be the same particle. 
@end deftypevr

The @strong{particle} protocol defines the @strong{points} component
that many other protocols are derived from. For example, the
@strong{NURBS} protocol uses the points defined by the particle
protocol as control vertices. There can be any number of properties
associated with particles including string per-particle.

The @strong{points} component is marked transposable in the its
ComponentHeader. This means that the properties in the component are
guaranteed to have the same number of elements. Because of this, the
data for the properties in a transposable component may be stored
differently than other components. For example, the normal state of
affairs is to write data like this:

@example
        position0 position1 position2 .... positionN
        velocity0 velocity1 velocity2 .... velocityN
        mass0 mass1 mass2 .... massN
@end example

So that you must read through all of the particle positions before you
can read the first particle's velocity. But this is not usually the best
way to read particle data for rendering. You may want to cull the
particles as you read them without storing the data. In order to do
this the data needs to be laid out like this:

@example
        position0 velocity0 mass0
        position1 velocity1 mass1
        position2 velocity2 mass2
        ...
@end example

In this case, each particle is scanned in one chunk allowing for
optimizations. Obviously this complicates reading, but in the case of
giga-particle renderers, this can be a huge memory savings.

@c ----------------------------------------------------------------------

@node Strands, NURBS Surfaces, Particles, Object Protocols
@section Strand Protocol

A @strong{strand} object contains a collection of curves. This is somewhat
analogous to an object of protocol @strong{particle} as described
above.

@deftypevr {Required Component} {} {points}
@end deftypevr

@deftypevr {Required Property} {float[3][]} {points.position}
The CVs which make up each curve.  The number of CVs per curve can vary by
curve type and size.
@end deftypevr

@deftypevr {Required Component} {} {strand}
Information that is relevent to the @emph{all} strands in the object.
@end deftypevr

@deftypevr {Required Property} {string[1][]} {strand.type}
String describing curve type.  Currently, supported values are @code{linear} for
degree 1 curves, or @code{cubic} for degree 3 curves.
@end deftypevr

@deftypevr {Optional Property} {float[1][1]} {strand.width}
If each end of all curves is the same width, you can just specify that one
number instead of the list as with @strong{elements.width} below.
@end deftypevr

@deftypevr {Required Component} {} {elements}
Information that applies to each separate strand in the object.
@end deftypevr

@deftypevr {Required Property} {int[1][]} {elements.size}
This is a list of the sizes of each curve in this object.  For example, if there
are two curves in this object, with 4 CVs and 3 CVs respectively, then:
@example
elements.size = [ 4 3 ]
@end example
@end deftypevr

@deftypevr {Optional Property} {float[2][]} {elements.width}
This is a list of the widths of each end of each curve.  The width for each
curve will be linearly interpolated over the length.
@end deftypevr

@c ----------------------------------------------------------------------

@node NURBS Surfaces, Polygonal Surfaces, Strands, Object Protocols
@section NURBS Protocol

The name of the protocol as it appears in the ObjectHeader is
``NURBS'' version 1. The protocol requires the @strong{particle} protocol
and optionally includes the @strong{object} and @strong{transform} protocols.

@deftypevr {Required Component} {} {points}
see @strong{particle} protocol. The points describe data per NURBS control
vertex.
@end deftypevr

@deftypevr {Required Property} {float[3][]} {points.position}
@deftypevrx {Required Property} {float[4][]} {points.position}
The position property holds the control point positions in its own
coordinate system or world space if it has no coordinate system. The
element is either a 3D or 4D (homogeneous) point. If the type is
float[4] the fourth component of the element will be the rational
component of the control point position. The control points are laid
out in @strong{@var{v}-major} order (@var{u} iterates more quickly than
@var{v}).
@end deftypevr

@deftypevr {Optional Property} {float[1][]} {points.weight}
If the position property is of type @code{float[3][]} there may
optionally be a ``weight'' property. This property holds the
homogeneous (rational) component of the position. Older GTO writers
may export data in this manner. The preferred method is to use a
@code{float[4]} element position.
@end deftypevr

@deftypevr {Required Component} {} {surface}
Properties related to the definition of a NURBS surface are stored in
this component.
@end deftypevr

@deftypevr {Required Property} {float[1][2]} {surface.degree}
The degree of the surface in @var{u} and @var{v}.
@end deftypevr

@deftypevr {Required Property} {float[1][]} {surface.uKnots}
@deftypevrx {Required Property} {float[1][]} {surface.vKnots}
The NURBS surface knot vectors in @var{u} and @var{v} are stored in
these properties. The knots are not piled. The usual NURBS
restrictions on how numbers may be stored in the knot vectors apply.
@end deftypevr

@deftypevr {Required Property} {float[1][2]} {surface.uRange}
@deftypevrx {Required Property} {float[1][2]} {surface.vRange}
The range of the knot parameters in @var{u} and @var{v}.
@end deftypevr

The @strong{NURBS} protocol currently does not handle trim curves, points on
surface, etc. Ultimately, the intent is to handle the trim curves and
other nasties as NURBS curves-on-surface which will be stored in
additional components. UBS surfaces can be stored as NURBS with
non-rational uniform knots.

@c ----------------------------------------------------------------------

@node Polygonal Surfaces, Subdivision Surfaces, NURBS Surfaces, Object Protocols
@section Polygon Protocol

The name of the protocol as it appears in the ObjectHeader is
``polygon'' version 2@footnote{In version 1 of the polygon protocol,
the @strong{element.size} and @strong{element.type} properties were
combined into an @strong{element.primitive} property. We felt that
this was adding unnecessary complexity and because the primitive
property was an int, it was taking up extra space.}. The protocol
requires the @strong{particle} protocol and optionally includes the
@strong{object} and @strong{transform} protocols.

There are a number of alternative configurations of this protocol
depending on the value of the @strong{smoothing.method} property. All
of these involve the placement of normals in the file.

@deftypevr {Required Component} {} {points}
See @strong{particle} protocol. The points describe data per vertex.
@end deftypevr

@deftypevr {Required Property} {float[3][]} {points.position}
The positions for regular polygonal meshes are stored as
@code{float[3]}. 
@end deftypevr

@deftypevr {Optional Property} {float[3][]} {points.normal}
Normals per vertex. The @strong{smoothing.method} property will have
the value of @emph{Smooth} if this property exists. Note that use of
the @emph{Smooth} smoothing method does not require that this property
exists. If it does not the method is merely and indication of how the
normals should be constructed. 
@end deftypevr

@deftypevr {Optional Component} {} {normals}
This component will exist if the value of @strong{smoothing.method} is
@emph{Partitioned} or @emph{Discontinuous}.
@end deftypevr

@deftypevr {Required Property} {float[3][]} {normals.normal}
This property is required only if the @strong{normals} component
exists and the value of @strong{smoothing.method} is
@emph{Partitioned} or @emph{Discontinuous}.
@end deftypevr


@deftypevr {Required Component} {} {elements} 
The elements component is
transposable. All properties in the elements component must have the same
number of elements. Each element corresponds to a polygonal primitive.  
@end deftypevr

@deftypevr {Required Property} {byte[1][]} {elements.type}
Elements are modeled after the OpenGL primitives of the same name. The
vertex order is identical to that defined by GL. The type numbers
outside those given here are not defined but reserved for future
use. So far, these are the define type numbers:

    @table @strong
    @item 0 -- Polygon
    General N-sided polygon. This can be used for any polygon that has 3 or more vertices.

    @item 1 -- Triangle
    A three vertex polygon.

    @item 2 -- Quad
    A four vertex polygon.

    @item 3 -- TStrip
    Triangle strip.

    @item 4 -- QStrip
    Quad strip. 

    @item 5 -- Fan
    Triangle fan. 

    @end table

@end deftypevr

@deftypevr {Required Property} {short[1][]} {elements.size}
The size of each primitive. Because the type is short, there is a
limit of 65k veritices per primitive.
@end deftypevr

@deftypevr {Optional Property} {short[1][]} {elements.smoothingGroup}
This property may exist if the value of @strong{smoothing.method} is
@emph{Partitioned}. In that case, this property indicates the
smoothing group number associated with each element. These can be used
to recompute the normals. These numbers are the same as those found in
the Wavefront .obj file format's ``s'' statements. A value of 0
indicates that an element is not in a smoothing group.
@end deftypevr

@deftypevr {Optional Property} {float[3][]} {elements.normal}
Normals per element. The @strong{smoothing.method} property will have
the value of @emph{Faceted} if this property exists. Note: the use of
@emph{Faceted} smoothing method does not require that this property
exists. If it does not, the smoothing method is merely and indication
of how the normals should be created.
@end deftypevr

@deftypevr {Required Component} {} {indices}
The indices component is transposable. All of its properties are
required to have the same number of elements. Each entry in the
indices component corresponds to a polygonal vertex.@footnote{The
@strong{indices} component in a polygonal object contains values which
are analogous to the RenderMan @code{facevarying} type modifier.}
@end deftypevr

@deftypevr {Required Property} {int[1][]} {indices.vertex}
A list of all the polygonal vertex indices in the same order as the
@strong{elements.primtives}. The indices refer to the @strong{points.position}
property. So if the first polygonal element is a triangle and second
is a general four vertex polygon then vertex indices will be something
like:

@example
    0 1 2 1 0 3 4 ...
@end example

which would be grouped as:

@example
    (0 1 2) (1 0 3 4) ...
@end example

The first group is the triangle and the second the polygon.
@end deftypevr

@deftypevr {Optional Property} {int[1][]} {indices.st}
Similar to the vertex indices but indicates indices into @var{st}
coordinates. These are usually stored in the ``mappings'' component
but may also appear in the @strong{points} component. 
@end deftypevr

@deftypevr {Optional Property} {int[1][]} {indices.normal}
Indices into stored normals if there are any. The
@strong{smoothing.method} property will have the value of
@emph{Partitioned} or @emph{Discontinuous} if this property exists.
@end deftypevr

@deftypevr {Optional Component} {} {mappings}
Contains parametric coordinates. The property names in mappings
usually correspond to names found in the @strong{indices} component
but not always. For example @strong{mappings.st} would be a
@code{float[2][]} property holding texture coordinates indexed by
@strong{indices.st}.
@end deftypevr

@deftypevr {Optional Component} {} {smoothing}
The smoothing component exists to hold the smoothing method and any
ancillary data for the method. If there is no smoothing component (and
hence no @strong{smoothing}) you can assume anything you want.
@end deftypevr

@deftypevr {Required Property} {int[1][1]} {smoothing}
There five defined smoothing methods (0 through 4). They are:

@c for some reason, makeinfo doesn't format the table text correctly
@c if the lines are broken. So I ran them all together. pdftex does
@c just fine either way

    @table @strong
    @item 0 -- None
    No smoothing method specified. No additional properties associated with normals will appear in the object.

    @item 1 -- Smooth 

    One normal at every vertex. There will be a @code{float[3][]} @strong{normal} property as part of the @strong{points} component. Each vertex has a unique normal.

    @item 2 -- Faceted

    One normal for each face. There will be a @code{float[3][]} @strong{normal} property in the @strong{elements} component. Each element has a unique normal.

    @item 3 -- Partitioned

    Same as the Wavefront .obj smoothing groups. There will be a @strong{normals} component containing a @code{float[3][]} @strong{normal} property and an @code{int[1][]} @strong{normal} propery in the @strong{indices} component. Each element vertex will have an index into the @strong{normals.normal} property.

    @item 4 -- Discontinuous

    Like @emph{Partitioned} but with additional lines and points of discontinuity. The same properties that hold the @emph{Partitioned} information will hold the @emph{Discontinuous} information. There will also be a component called @strong{discontinuities} which will have a @code{int[1][]} property called @strong{indices} indicating the points and lines of discontinuity.

    @end table

@end deftypevr

@c ----------------------------------------------------------------------

@node Subdivision Surfaces, Image, Polygonal Surfaces, Object Protocols
@section Subdivision Surface Protocols

The name of the protocol as it appears in the ObjectHeader is
``catmull-clark'' or ``loop'' depending on the intended subdivision
scheme. The protocol requires the @strong{polygon} protocol.

The smoothing and any normals properties on the @strong{polygon} protocol
should be ignored if they exist.

The protocol indicates how the surface should be treated. Note that
the canonical element type for each of the two schemes is not
guaranteed to be the only element type stored in the file. For
catmull-clark this means that triangles and general polygons will
need to be made into quads. Similarily loop surfaces may have
quads and other non-triangle primitives that need to be triangulated.

These protocols do not currently define methods for storing edge
creasing parameters.

Disclaimer: there are restrictions on what kind of topology surfaces
are allowed to have for a given renderer (for example). In most cases
surfaces need to be manifold. Some applications can deal with special
cases better than others.

@c ----------------------------------------------------------------------

@node Image, Material, Subdivision Surfaces, Object Protocols
@section Image Protocol

The Image protocol describes image data in the form of an object. This
data makes it possible to store texture maps, backgrounds, etc,
directly in the GTO file. 

When images are stored in a GTO file, use of Gzip compression is
highly recommended if the data is unencoded. As of version 2.1, the 
supplied Reader and Writer classes default to using zlib compression.

If the image data is encoded, its better @emph{not} to use 
compression on the GTO file (especially if the file contains only
image data).

@deftypevr {Required Component} {} {image}
The image data and other information will be stored in the
@strong{image} component.
@end deftypevr

@deftypevr {Required Property} {int[1][]} {image.size}
The size (and dimension) of the image. There will be N sizes in this
property corresponding to the N dimensions of the image.
@end deftypevr

@deftypevr {Required Property} {string[1][1]} {image.type}
The image type. For interactive purposes, the image channels may
correspond to a particular fast hardware layout.

@itemize @bullet
@item @code{RGB}
Three channels corresponding to red, green, and blue in that order.
@item @code{BGR}
Three channels corresponding to blue, green, and red in that order.
@item @code{RGBA}
Four channels corresponding to red, green, blue, and alpha in that
order.
@item @code{ABGR}
Four channels corresponding to alpha, blue, green, and red in that
order.
@item @code{L}
One channel corresponding to luminance.
@item @code{HSV}
Three channels corresponding to hue, saturation, and value. (The HSV
color space).
@item @code{HSL}
Three channels corresponding to hue, saturation, and lightness. (The
HSL color space).
@item @code{YUV}
Three channels corresponding to the YUV color space.
@end itemize
@end deftypevr


@deftypevr {Optional Property} {int[1]} {image.cs}
The coordinate system of the image. The value of @strong{image.cs} can
be any one of the following:

@table @strong
    @item 0 -- Lower left origin.
The first pixel in the image data is the lower left corner of the
image data and corresponds to NDC coordinate (0,0). 

    @item 1 -- Upper left origin.
The first pixel in the image data is the upper left corner of the
image data and corresponds to NDC coordinate (0,0).
@end table
@end deftypevr

Any one of the following properties are required to hold the actual
image data:

@deftypevr  {Property} {byte[N][]} {image.pixels}
@deftypevrx {Property} {short[N][]} {image.pixels}
@deftypevrx {Property} {half[N][]} {image.pixels}
@deftypevrx {Property} {float[N][]} {image.pixels}
The element width determines the number of channels in the image. For
example, the type @code{byte[3][]} indicate a 3 channel 8-bit per
channel image. The number of elements in this property should be equal
to @code{image.size[0] * image.size[1] * ... image.size[N]} where
@strong{image.size} is the property defined above.
@end deftypevr

@subsection Additional Image Properties Used by GTV Files.

The base GTO library does not deal with encoded image data or tiling
of images. GTV is a specialization of the GTO format for storing
movie frames. Some of the GTV properties are documentated here. (See
documentation for the GTV library for more info).

@deftypevr {Optional Property} {string[1]} {image.encoding}
If the pixel data is encoded this property will indicate a method to
decode it. Typical valies are ``jpeg'', ``jp2000'', ``piz'',
``rle'', or ``zip''. The pixels will be stored in the 
@strong{image.pixels} as @code{byte[1][]}. 
@end deftypevr

@c ----------------------------------------------------------------------

@node Material, Group, Image, Object Protocols
@section Material Protocol

The name of the protocol as it appears in the ObjectHeader is
``material''. The material protocol groups a parameters and a method
(shader) for rendering. The material protocol can optionally include
the @strong{object} protocol.

The material definition is renderer and pipeline dependant. Material
assignment is implemented using the @strong{connection}
protocol. @xref{Inter-Object}.

The @strong{material} protocol is intended for use with software
renderers. Interactive material definitions may be more easily defined
on the assigned object.

@deftypevr {Required Component} {} {material}
Properties unrelated to parameters appear in the @strong{material}
component. 
@end deftypevr

@deftypevr {Required Property} {string[1][1]} type
The value of the @strong{material.type} property is renderer
dependant. For a RIB renderer, the value of type might be ``Surface'',
``Displacement'', ``Atmosphere'' or a similar shader type name. 
@end deftypevr

@deftypevr {Optional Property} {string[1][1]} shader
The name of the shader. For RenderMan-like renderers this might be the
name of an ``.sl'' file.
@end deftypevr

@deftypevr {Optional Property} {string[1][1]} genre
A property to further identify the material. This is most useful for
identifying the target renderer for a material.
@end deftypevr

@deftypevr {Optional Component} {} {parameters}
The set of parameters corresponding to the @strong{material.type}. 
@end deftypevr


@c ----------------------------------------------------------------------

@node Group, Inter-Object, Material, Object Protocols
@section Group Protocol


@c ----------------------------------------------------------------------
@node Inter-Object, Difference, Group, Object Protocols
@section Inter-Object Connection Protocol

The name of the protocol as it appears in the ObjectHeader is
``connection'' version 1. 

Files which employ the @strong{connection} protocol will typically
contain a connection object with the special cookie name
``:connections'' indicating the purpose of the object as well as
preventing namespace pollution. @xref{Special Cookies}.

Each component in a connection object is a connection type. For
example, the ``parent_of'' connection type is used to represent
transformation hierarchies. In a connection object, there will be a
single component called ``parent_of'' which will contain the required
properties @strong{parent_of.lhs} and @strong{parent_of.rhs} at a
minimum. Some connection types may have additional data in the form of
additional properties. 

Connection components are transposable. The number of elements in
properties comprising a connection component will be consistant. So a
single ``parent_of'' component can encode an entire scene
transformation hierarchy.

Connection components have the following properties. Note that where
@strong{connection_type} occurs in the property name, you would
substitute in the actual name of the connection
type. (``parent_of'' for example).

@deftypevr  {Required Property} {string[1][]} {connection_type.lhs}
@deftypevrx {Required Property} {string[1][]} {connection_type.rhs}
The left-hand-side and right-hand-side of the connection. 

@itemize @bullet
@item
If the connection is directional, then an arrow indicating the
direction would have its tail on the left-hand-side and its head
pointing at the right-hand-side.

@item
If the connection type does not require a direction then these
properties are still used to describe the two ends of the
connection. 

@item
Each entry will be the name of an object. There is no requirement that
the ends of the connection exist in the file. For example, one end of
the connection could be an image on disk. 

@item
The empty string is a valid value. You could think of the empty string
as indicating a grounded connection. 

@item
Its ok for both ends of the connection to have the same value.
@end itemize

@end deftypevr

The GTO specification includes a couple of basic connection types.

@menu
Connection Types Defined by the Spec

* parent_of::             Transformation hierarcies.
* material::              Material assignments.
* contains::              Group/Container assignment.

@end menu

@c ----------------------------------------
@node parent_of, material, Inter-Object, Inter-Object
@subsection Transformation hierarchies.

The ``parent_of'' connection type is used to store transformation
hierarchies. The connection type requires only the @strong{lhs} and
@strong{rhs} properties. Transformation hierarchies are usually tree
structures, but can also be DAGs (as is the case with Maya or
Inventor). 

Using ``parent_of'' as a cyclic generalized network connection is
probably an error for most applications. To be safe the topology of a
``parent_of'' network should be a tree.

@c ----------------------------------------
@node material, contains, parent_of, Inter-Object
@subsection Material Assignment

The ``material'' connection type indicates a material assignment to an
object. The left-hand-side name is a renderable object in a GTO file
The right-hand-side is the name of a material object in a GTO
file. 

@c ----------------------------------------
@node contains,  , material, Inter-Object
@subsection Container Assignment

The ``contains'' connection type indicates membership in a group or
similar type of container object. The LHS is the group or container,
the RHS is the object which is a member.

@c ----------------------------------------------------------------------

@node Difference, Sorted Shells, Inter-Object, Object Protocols
@section Difference File Protocol

If the @strong{object.protocol} property contains the string
``difference'' then the object contains difference data; the data is
relative to some other reference file. 

For example, for animated deforming geometry its advantageous to write
a reference file for geometry in its natural undeformed state then
write only the @strong{points.position} property in a gto file per
frame to store animation. The @strong{difference} minor protocol can
apply to any major protocol.

If a reference file and a difference for file it exists, you can
reconstruct the file represented by the difference file using the
@command{gtomerge} command. @xref{gtomerge}.

@c ----------------------------------------------------------------------

@node Sorted Shells, Channels, Difference, Object Protocols
@section Sorted Shell File Protocol

If the @strong{object.protocol} property contains the string
``sorted'' and the object's major protocol is @strong{polygon} then
the object contains sorted shell data.

This protocol guarantees that the vertices and elements of shells ---
isolated sections of polygonal geometry --- will be continguous in the
@strong{points} and @strong{elements} components of the object.

@deftypevr {Required Component} {} {shells}
The @strong{shells} component is transposable. Each property in the
component should have the same number of elements. 
@end deftypevr

@deftypevr {Required Property} {int[1][]} {shells.vertices}
The number of contiguous vertices that make up the Nth element's
shell.
@end deftypevr

@deftypevr {Required Property} {int[1][]} {shells.elements}
The number of contiguous elements that make up the Nth element's
shell.
@end deftypevr

@c ----------------------------------------------------------------------

@node Channels, Animation, Sorted Shells, Object Protocols
@section Channels Protocol

This minor protocol declares data mapped onto geometric
surfaces. Usually the data is mapped using one of the
parameterizations found in the @strong{mappings} component of
polygonal or sub-d geometry or possibly using the natural
parameterization of a surface as is often the case with NURBS.

Each declared channel appears as a @code{string[1][]} property of a
@strong{channels} component on the geometry. The name of the property
is the name of the channel. The property should contain at least one
element. 

The first element of the property should indicate the name of the
mapping to use. This is either the name of one of the properties in
the @strong{mappings} component or ``natural'' indicating that the
natural parameterization of the surface should be used.

The second and subsequent elements should contain the name of data to
map. This could be a texture map file on disk, an image object in the
GTO file, or a special cookie string. The lack of second element can
be used as a special cookie.

@deftypevr {Required Component} {} {channels}
The component holds the names of all the channels on the geometry.
@end deftypevr

@subsection Example

Here is a cube with ``color'', ``specular'', and, ``bump'' channels
assigned. 

@example
    Object "cube" protocol "polygon"
        Component "points"
            Property float[3][8] "position"
        Component "elements"
            Property byte[1][8] "type"
            Property short[1][8] "size"
        Component "indices"
            Property int[1][32] "vertex"
            Property int[1][32] "st"
        Component "mappings"
            Property float[2][24] "st"
        Component "channels"
            Property string[1][2] "color"
            Property string[1][2] "specular"
            Property string[1][2] "bump"
@end example

The contents of the ``channels'' properties might be:

@example
string[1] cube.channels.color    = [ "st" "cube_color.tif" ]
string[1] cube.channels.specular = [ "st" "cube_specular.tif" ]
string[1] cube.channels.bump     = [ "st" "cube_bump.tif" ]
@end example


@node Animation,  , Channels, Object Protocols
@section Animation Curve Protocol

The animation curve protocol defines a single component called
@strong{animation} in which each property holds an animation curve or
data stream. The property's interpretation string indicates how the
data should be evaluated.

@subsection Example

Here is a cube with animation curves. 

@example
    Object "cube" protocol "polygon"
        Component "points"
            Property float[3][8] "position"
        Component "elements"
            Property byte[1][8] "type"
            Property short[1][8] "size"
        Component "indices"
            Property int[1][32] "vertex"
        Component "animation"
            Property float[6][2] "xtran" interpret as "bezier"
            Property float[6][2] "ytran" interpret as "bezier"
            Property float[6][2] "ztran" interpret as "bezier"
            Property float[6][5] "xrot" interpret as "bezier"
            Property float[6][8] "yrot" interpret as "bezier"
            Property float[6][10] "zrot" interpret as "bezier"
            Property float[1][100] "xscale" interpret as "stream"
@end example

@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------

@node Names, Issues, Object Protocols, Top
@chapter Naming Conventions

GTO files can contain cross references to parts of themselves, objects
outside the file, or virtual/logical objects in applications. Because
of the potential morass that can result from complete free-form
naming, there are conventions which are part of the file
specification. 

Failure to follow the guidelines does not mean a GTO file is
ill-formed; there's always a good reason to ignore guidelines. But
having a basis for consistancy is usually a good idea.

Some of these topics are a bit ``advanced'' in that they build off
ideas that present themselves after using the file format for a
while. If you are just learning about the format, consider this a
reference section and skip it. If you're trying to decrypt a
complicated GTO file with strange garbled naming, then this section is
for you.

@menu

* Valid Names::             General Guidelines.
* Path Names::              Exactly specifying a property or component.
* Special Cookies::         Indicating special handling.
* Cross References::        Cross references encoded in names.
@end menu

@c ----------------------------------------------------------------------
@node Valid Names, Path Names, Names, Names
@section Valid Names

Names should be valid C identifiers, but should not contain the
dollar-sign character ($). This means that no whitespace or
punctuation is allowed. 

Note that this does @emph{not} apply to protocol names.

There is nothing in the sample @code{Reader} or @code{Writer} classes
which enforces the valid name guideline. However, some applications
(Maya) cannot handle names with whitespace and/or punctuation. So
plug-ins which implement GTO reading/writing will have to enforce the
application's specific naming requirements.

This guideline is broken by @ref{Special Cookies}. Its also broken by
@ref{Cross References}.

@c ----------------------------------------------------------------------
@node Path Names, Special Cookies, Valid Names, Names
@section Exactly Specifying a Property or Component

By convention, the full name or path name of a property is refered to
like this:

@example
    OBJECTNAME.COMPONENTNAME.PROPERTYNAME
@end example

When indicating a property name relative to an object then:

@example
    COMPONENTNAME.PROPERTYNAME
@end example

should suffice. In this manual, names of components and properties are
disambiguated using the dot notation. In addition, this is the format
of output from the @command{gtoinfo} command. There is nothing about
the GTO file itself which relates to this notation other than the
cross-referencing naming convention discussed below. 

@c ----------------------------------------------------------------------
@node Special Cookies, Cross References, Path Names, Names
@section Indicating Special Handling

Some objects, components, or properties in the GTO file may contain
data for which names are not particularily useful or that may simply
pollute the object or component namespace.

In other cases (component names most notably) the name may be used as
information necessary to interpret data associated with it.

In order to distinguish these names from run-of-the-mill names, you
should include a colon in the name. Names with colons are considered
``special cookie'' names and objects which have them may be handled
differently than other objects. 

The @strong{connection} object protocol, for example, requires that a
special file object exist to hold data. This object is not necessarily
related to a logical object in the application, its just a container
for the connection data. These objects are named using the special
cookie syntax. Usually the name is
``:connections''. @xref{Inter-Object}.

There is no rule regarding the placement of the colon in the name; it
can appear anywhere in the name that is useful for the
application. However, if the entire name is a special cookie --- there
is not additional information encoded in the name beyond itself ---
the recommend form is to have the colon be the first character.

@c ----------------------------------------------------------------------
@node Cross References,  , Special Cookies, Names
@section Cross References Encoded in Names

Sometimes there is a need to have a property or component @emph{refer}
to another property, component, or object in the file (or somewhere
else). 

To cross reference the data in one property with another, simply name
the property the full (or partial) path to the referenced
property. For example, here's the output of @command{gtoinfo} on a GTO
file which has cross referencing properties:

@example
object "gravity" protocol "gravity" v1
  component "field"
    property float[3][1] "direction" 
    property float[1][1] "magnitude" 
  component ":datastream"
    property float[3][300] "field.direction" 
    property float[1][300] "field.magnitude" 
@end example

As you can guess, the intention here is that the properties called
``field.direction'' and ``field.magnitude'' in the ``:datastream''
component are data that is associated with the properties
``direction'' and ``magnitude'' in the ``field'' component. 


@c -------------------------------------------------------------------------
@c -------------------------------------------------------------------------

@node Issues, Extending, Names, Top
@chapter Issues and Questionable Aspects of the Format

@itemize @bullet

@item
There are currently no (publicly available) tools which verify that a
file claiming to follow some protocol is correct.

@item
There is no 3D curve(s) protocol defined.

@item
The @strong{NURBS} protocol does not handle trim curves. @xref{NURBS
Surfaces}.

@item
The format does not contain dedicated space for auxillary information
like the name and version of the program that wrote the file, the
original owner, copright information, etc. However, our tools use the
string table for these type of data -- since its not an error have an
unused interned string, we store the data as such. In our opinion,
this is a fairly innocuous method. You can read unreferenced strings
by using the @command{gtoinfo} command with the @option{-s}
option. Note that these strings are often lost when programs read and
write the file.  @xref{gtoinfo}.

@item
Although the format specification includes transposable components
(those marked with the Gto::Matrix flag may be transposed), the
current reader/writer library does not handle files with transposed
components. It does handle components that are marked as Gto::Matrix
but not transposed. @xref{Particles}.

@item
The use of special cookie names and special cross-reference names
seems to seriously complicate the format if the protocol is not
carefully conceived. For example, using @command{gtomerge} to merge
files containing connections does not work --- the connections are
merged like all the other data in the file. The correct behavior would
be to combine the connections, but merge the other object
data. Perhaps this is just a case for integrating @command{gtocombine}
into @command{gtomerge}?

@item
Future versions should incorporate some form of check sum or some
similar mechanism to do better sanity checking.

@item
There are many examples of properties whose data indexes into other
property data. The most obvious of these are the polygon protocol
@strong{indices} properties. In order to combine gto files
(concatenate polygonal data together for example) its necessary to
know which properties are indexes and which are not. Index properties
must be offset to be combined.

@item
The Boolean (bit fields) and Half data types are not implemented in
the supplied writer library. Both of these types are useful in
compressing geometric (and image) data.

@item
Material, Texture, and similar assignments and storage are usually
very specialized at any particular production facility. The idea that
a single method of encoding this information can be determined or
enforced --- or even usefully be stored in a GTO file --- is not
realistic. However, we hope that some method can be determined that at
least preserves a good portion of common data for transfer. 

All of the protocols related to these concepts are marked
@strong{PROPOSED} in this
document.
@xref{Material}. @xref{material}.

@end itemize

@c -------------------------------------------------------------------------
@c -------------------------------------------------------------------------

@node Extending, Library, Issues, Top
@chapter Extending Protocols or the File Format

If you have an extension to a protocol or would like to change an
existing protocol, we would like to hear about it. You can send mail
to  with the changes you're using or would
like made. We will collect ideas and proposals and try to make
releases in a timely manner. We'd also like to hear from you if you're
using it unmodified.

There is currently a small number of facilities that use the GTO
format, but there is a large collection of tools that use it. Most
proposals should maintain some backwards compatibility. However, we
recognize that the there may be flaws that require revamping
significant pieces and we're open to making changes to accommodate
other facilities.

If you are using the format for academic purposes and are looking for
a specific tool to munge GTO files, we may already have that tool
even though it is not released. Contact us; we might be able to help
you out.

We have been using the format since summer 2002 on a regular basis in
production at Tweak Films and have found it stable and useful. The
version of the code we use is identical to the released version.

@c -------------------------------------------------------------------------
@c -------------------------------------------------------------------------

@node Library, Module, Extending, Top
@chapter C++ Library

The GTO Reader/Writer library is written in a subset of C++. The
intention was to make the library as portable as
possible. Unfortunately we have only tried it on platforms that
support gcc 2.95 and greater. It is known to work on various Linux
versions and Mac OS X. In either case it has been compiled with gcc.

@menu
* Reader::                      Read GTO files by deriving from the Reader.
* Writer::                      Write GTO files by using a Writer instance.
* RawData::                     RawData classes.
@end menu

@c ----------------------------------------------------------------------

@node Reader, Writer, Library, Library
@section Gto::Reader class

The Reader class (in namespace Gto) is designed as a fill-in-the-blank
API. The user of the class derives from it; the base class defines a
number of virtual functions which pass data to the derived class and
ask the derived class questions about what data it wants.

The Reader class handles most of the difficult work in reading the
file like keeping track of headers, sizes of properties, and the order
of data. In addition, it handles the string table and looking up
property string values. If the file was written by a machine with
different sex (endianess) it will translate the data for you. 

In addition, you can compile the GTO library with zlib support. This
enables the Reader class to read gzipped GTO files natively and the
Writer class to write them. This can be a significant space savings on
disk and on saturated networks can make file loading faster. You can
also pass a C++ istream object to the Reader if you want to read
``in-core''.

As the file is read, the Reader class will call its virtual functions
to declare objects in the file to the derived class. The derived class
is expected to return a non-null pointer if it wishes to later receive
data for that object.

@deftypefn {Constructor} {} Reader::Reader (unsigned int @var{mode})
The constructor argument @var{mode} indicates how the reader will be
used. This value is a bit vector of the following or'ed flags:

@table @strong
@item Reader::None
The reader will be used in its standard @emph{streaming} mode. The
reader will attempt to read all the data in the file. This is the
default value (or 0).

@item Reader::HeaderOnly
The reader will stop once it has read the header sections of the GTO
file. This is an optimization that applies to binary files only. This
option is ignored when reading a text file.

@item Reader::RandomAccess
The reader will read the header sections but not the data, however, it
will initialize for use of the @code{Reader::accessObject()}
function. Only binary GTO files can be read using the radom access mode.

@item Reader::BinaryOnly
Only binary GTO files will be accepte by reader.

@item Reader::TextOnly
Only text GTO files will be accepte by reader.

@end table
    
@end deftypefn

@deftypefn {Destructor} {} Reader::~Reader ()
Closes file if still open.
@end deftypefn

@deftypefn {Method} bool Reader::open (const char* @var{filename})
Open the file. The Reader will attempt to open file 
@var{filename}.  If the file does not exist and zlib support is compiled
in, the Reader will attempt to look for @var{filename}.gz and open it instead.
@end deftypefn

@deftypefn {Method} bool Reader::open (std::istream&, const char* @var{name})
Reads the GTO file data from a stream. The @var{name} is supplied to
make error messages make sense.
@end deftypefn

@deftypefn {Method} void Reader::close ()
Close the file and clean up temporary data. If the stream constructor
was used, the stream is @emph{not} closed.
@end deftypefn

@deftypefn {Method} std::string& Reader::fail (std::string @var{why})
Sets the error condition on the Reader and sets the human readable
reason to @var{why}.
@end deftypefn

@deftypefn {Method} std::string& Reader::why ()
Returns a human readable description of why the last error occured. (Set
by the @code{fail()} function).
@end deftypefn

@deftypefn {Method} {const std::string&} Reader::stringFromId (unsigned int)
Given a string identifier, this method will return the actual string
from the string table.
@end deftypefn

@deftypefn {Method} {const StringTable&} Reader::stringTable ()
Returns a reference to the entire string table.
@end deftypefn

@deftypefn {Method} {bool} Reader::isSwapped () const
Returns true if the file being read needed to be swapped. This occurs
if the machine the file was written on is a different sex than the
machine reading the file (for example a Mac PPC written file read on
an x86 GNU/Linux box).
@end deftypefn

@deftypefn {Method} {unsigned int} Reader::readMode () const
Returns the mode value passed into the Reader constructor.
@end deftypefn

@deftypefn {Method} {const std::string&} Reader::infileName () const
Returns the name of the file or stream being read. This is the value
passed in to the @code{Reader::open()} function.
@end deftypefn

@deftypefn {Method} {std::istream*} Reader::in () const
Return the input stream created by or passed into @code{Reader::open()}. If the GTO
file is compressed binary, this function will return NULL.
@end deftypefn

@deftypefn {Method} {int} Reader::linenum () const
For text GTO files, the return value will be the current line being
parsed. For binary GTO files, the return value is always 0.
@end deftypefn

@deftypefn {Method} {int} Reader::charnum () const
For text GTO files, the return value will be the current char column (in
the current line) being parsed. For binary GTO files, the return value
is always 0.
@end deftypefn

@deftypefn {Method} {Header&} Reader::fileHeader () const
Returns a reference to a Gto::Header structure corresponding to the file
currently being read. This function is required by the text file
parser. The function may disappear from future versions. See the
@code{Reader::header()} function below for a better way to get header information.
@end deftypefn

The following functions are called by the base class.

@deftypefn {Virtual} {void} Reader::header (const Header& @var{header})
This function is called by the Reader base class right after the file
header has been read (or created).  
@end deftypefn

@deftypefn {Virtual} {void} Reader::descriptionComplete ()
This function is called after all file, object, component, and
property structures have been read. For binary files, this is
just before the data is read. For text files, this is after the
entire file has been read.
@end deftypefn

The following functions return a @code{Reader::Request} object. This
object takes two parameters: a boolean indicating whether the data
in question should be read by the reader and a second optional data
@code{void*} argument of user data to associate with the file data.

@deftypefn {Constructor} {} Reader::Request::Request (bool @var{want}, void* @var{data})
@var{want} value of true indicates a request for the data in
question. @var{data} can be any void*. @var{data} is meaningless if
the @var{want} is false.
@end deftypefn

@deftypefn {Virtual} {Reader::Request} Reader::object (const std::string& @var{name}, const std::string& @var{protocol}, unsigned int @var{protocolVersion}, const ObjectInfo& @var{header})
This function is called whenever the Reader base class encounters an
ObjectHeader. The derived class should override this function and
return a Request object to indicate whether data should be read for
the object in question. If it requests not to have data read, the
Reader will not call the corresponding component() and property()
functions.
@end deftypefn

@deftypefn {Virtual} {Reader::Request} Reader::component (const std::string& @var{name}, const ComponentInfo& @var{header})
This function is called when the Reader base class encounters a
ComponentHeader in the GTO file. If the derived class did not express
interest in a particular object in the file by returning
@code{Request(false)} from the object() function, the components of
that object will not be presented to the derived class. The derived
class should return @code{Request(true)} to indicate that it is interested in the
properties of this @var{component}.
@end deftypefn

@deftypefn {Virtual} {Reader::Request} Reader::property (const std::string& @var{name}, {const char*} @var{interpString}, const PropertyInfo& @var{header})
This function is called when the Reader base class encounters a
PropertyHeader in the GTO file. If the derived class did not express
interest in a particular object or the component that the property
belongs to, the properties of that component will not be presented to
the derived class. The derived class should return
@code{Request(true)} to indicate it is interested in the property
data.
@end deftypefn

@deftypefn {Virtual} {void*} Reader::data (const PropertyInfo&, size_t @var{byts})
This function is called before property data is read from the GTO
file. The function should return a pointer to memory of at least size
@var{bytes} into which the data will be read. The type, size, width,
etc, of the data can be obtained from the @code{PropertyInfo} structure.
@end deftypefn

@deftypefn {Virtual} {void} Reader::dataRead (const PropertyInfo&)
This function is called after the @code{data()} function if the data
was successfully read. 
@end deftypefn

If you are using the Reader class in @code{Reader::RandomAccess} mode,
you may call these functions after the read function has returned:

@deftypefn {Method} {Reader::Objects&} Reader::objects ()
Returns a reference to an std::vector of Reader::ObjectInfo
structures. These are only valid after @code{Reader::open()} has
returned. You can use these structures when calling
@code{Reader::accessObject()}. 
@end deftypefn

@deftypefn {Method} {const Reader::Components&} Reader::components ()
Returns a reference to an std::vector of Reader::ComponentInfo
structures. These are only valid after @code{Reader::open()} has
returned. This method is most useful when deciding how to call the
@code{accessObject} function.
@end deftypefn

@deftypefn {Method} {const Reader::Properties&} Reader::properties ()
Returns a reference to an std::vector of Reader::PropertyInfo
structures. These are only valid after @code{Reader::open()} has
returned. This method is most useful when deciding how to call the
@code{accessObject} function.
@end deftypefn

@deftypefn {Method} {void} Reader::accessObject (const ObjectInfo&)
Calling this function on a GTO file openned for @code{RandomAccess}
reading will cause the reader to seek into the file just for the data
related to the object passed in. This is most useful when the objects'
data cannot be held in memory and the order of retrieval is
unknown. The reader attempts to be efficient as possible without using
too much memory.
@end deftypefn

@c -------------------------------------------------------------------------
@node Writer, RawData, Reader, Library
@section Gto::Writer class

The Writer class (in namespace Gto) is designed as an API to a state
machine. You indicate a conceptual hierarchy to the file and then all
the data. The writer handles generating the string table, the header
information, etc.

The following is an example that outputs a polygon cube using the
@strong{polygon} protocol.

@example

    float points[3][] = 
    @{   @{ -2.5, 2.5, 2.5 @},  @{ -2.5, -2.5, 2.5 @}, 
        @{ 2.5, -2.5, 2.5 @},  @{ 2.5, 2.5, 2.5 @}, 
        @{ -2.5, 2.5, -2.5 @}, @{ -2.5, -2.5, -2.5 @}, 
        @{ 2.5, -2.5, -2.5 @}, @{ 2.5, 2.5, -2.5 @} @};

    unsigned char type[] = @{ 2, 2, 2, 2, 2, 2 @};
    unsigned char size[] = @{ 4, 4, 4, 4, 4, 4 @};

    int indices[] = @{0, 1, 2, 3,    7, 6, 5, 4, 
                     3, 2, 6, 7,    4, 0, 3, 7, 
                     4, 5, 1, 0,    1, 5, 6, 2 @};

    Gto::Writer writer;
    writer.open("cube.gto");

    writer.beginObject("cube", "polygon", 2);   // polygon version 2

        writer.beginComponent("points");
            // will write 8 float[3] positions
            writer.property("positions", Gto::Float, 8, 3);
        writer.endComponent();

        writer.beginComponent("elements");
            // one per face
            writer.property("size", Gto::Short, 8, 1, 1);
            writer.property("type", Gto::Byte, 8, 1, 1);
        writer.endComponent();

        writer.beginComponent("indices");
            // one per vertex per face
            writer.property("vertex", Gto::Int, 24, 1, 1);
        writer.endComponent();

    writer.endObject();

    // repeat writer object blocks if more objects

    // output all the data in order declared

    writer.beginData();
    writer.propertyData(points);
    writer.propertyData(type);
    writer.propertyData(size);
    writer.propertyData(indices);
    writer.endData();

@end example

@deftypefn {Constructor} {} Writer::Writer ()
Creates a new Writer class object. Typically you'll make one of these
on the stack. This constructor requires you call the open function to
actually start writing the file.
@end deftypefn

@deftypefn {Constructor} {} Writer::Writer (std::ostream&)
Creates a new Writer class object which will output to the passed C++
output stream.
@end deftypefn

@deftypefn {Destructor} {} Writer::~Writer ()
Closes file opened with the @code{open()} function if still open. The
destructor will not close any passed in output stream.
@end deftypefn

@deftypefn {Method} bool Writer::open (const char* @var{filename}, FileType @var{mode} = CompressedGTO)
Open the file. The Writer will attempt to open file @var{filename}.  If
the file is not writable for whatever reason, the function will return
false. If @var{mode} is @code{CompressedGTO} (the default value), the
Writer class will output a binary compressed file. If the value is
@code{BinaryGTO} the file will be binary uncompressed. If @var{mode} is
@code{TextGTO} a text GTO file will be written. Compressed GTO files can
be uncompressed manually using @command{gzip}. Compression is available
only if the library is compiled with zlib support.
@end deftypefn

@deftypefn {Method} bool Writer::open (const char* @var{filename}, bool @var{compress} = true)
This function exists for backwards compatibility. Use the other
@code{open()} function instead. This function can open a file for binary
output only (it cannot write a text GTO file).
@end deftypefn

@deftypefn {Method} void Writer::close ()
Close the file and clean up temporary data. If the stream constructor
was used, the stream is @emph{not} closed.
@end deftypefn

@deftypefn {Method} {void} Writer::beginObject (const char* @var{name}, const char* @var{protocol}, unsigned int @var{version}) const
Declares an object. Its components and properties must be declared
before @code{endObject()} is called. The @var{name} is the name of the object
as it will appear in the gto file. The @var{protocol} is the protocol
string indicating how the object data will be interpreted and the
@var{version} number indicates the protocol version. The Writer class
does not verify that the data output conforms to the protocol.
@end deftypefn

@deftypefn {Method} {void} Writer::beginComponent (const char* @var{name}, bool @var{transposed}=false) 
Declares a component. The component properties must be declared before
a call to endComponent(). The @var{name} is the name of the component
as it will appear in the gto file. The @var{transposed} flag is
optional and indicates whether or not the component property data
should be output transposed or one property at a time (the default).
@end deftypefn

@deftypefn {Method} {void} Writer::property (const char* @var{name}, Gto::DataType @var{type}, size_t @var{numElements}, size_t @var{partsPerElement}=1, {const char*} @var{interpString}=0)
Declare a property. The @var{name} is the name of the property as it
appears in the gto file. The @var{type} is one of @code{Gto::Double},
@code{Gto::Float}, @code{Gto::Int}, @code{Gto::String},
@code{Gto::Byte}, @code{Gto::Half}, or
@code{Gto::Short}. @var{numElements} indicates the number of elements of size
@var{partsPerElement} that will be in the property data. So for
example, if the property is declared as a Gto::Float of
with @var{partsPerElement} of 3 and there 10 of them, then the writer
will expect an array of 30 floats when the propertyData is finally
passed to it. The last argument @var{interpString} is an optional
interpretation string that can be stored with the property.
@end deftypefn

@deftypefn {Method} {void} Writer::endComponent ()
Closes the declaration of a component started by @code{beginComponent()}.
@end deftypefn

@deftypefn {Method} {void} Writer::endObject ()
Closes the declaration of an object started by @code{beginObject()}.
@end deftypefn

@deftypefn {Method} {void} Writer::intern (const char* @var{string})
Declares a string to the Writer for inclusion in the file string
table. When writing properties of type @code{Gto::String}, its necessary to
call this function before the @code{beginData()} is called. Each string in
the property data must be interned. When outputing the property, the
property will be an array of @code{Gto::Int} in which each int is the result
of the @code{lookup()} function which retrieves a unique int corresponding to
interned strings. 
@end deftypefn

@deftypefn {Method} {void} Writer::intern (const std::string& @var{string})
Same as above, but takes an @code{std::string}.
@end deftypefn

@deftypefn {Method} {int} Writer::lookup (const char* @var{string})
Retrieve the identifier of the previously interned string
@var{string}. 
@end deftypefn

@deftypefn {Method} {int} Writer::lookup (const std::string& @var{string})
Same as above, but takes an @code{std::string&}.
@end deftypefn

@deftypefn {Method} {void} Writer::beginData ()
Begins data declaration to the Writer class. Only calls to
@code{lookup()}, @code{propertyData()}, @code{propertyDataInContainer()}, and
@code{endData()} are legal after @code{beginData()} is called.
@end deftypefn

@deftypefn {Method} {void} Writer::propertyData (const TYPE* @var{type})
@code{propertyData()} is a template function which takes a pointer to
continuously stored data. The data must be the same as declared
earlier by the @code{property()} function. Calls to
@code{propertyData()} and
@code{propertyDataInContainer()} must appear in the same order as the
@code{property()} declarations calls.
@end deftypefn

@deftypefn {Method} {void} Writer::propertyDataInContainer (const TYPE& @var{container})
@code{propertyDataInContainer()} is a template function which takes an stl-like
container as an argument. The data must be the same as declared earlier
by the @code{property()} function. Calls to @code{propertyData()} and
@code{propertyDataInContainer()} must appear in the same order as the
@code{property()} declarations calls. This function is a convenience
function; it calls propertyData() to actually output the data. This
function may make a copy of the data in the container.
@end deftypefn

@deftypefn {Method} {void} Writer::endData ()
Closes the definition of data started by @code{beginData()} and finishes
writing the gto file.
@end deftypefn

@deftypefn {Method} {const Writer::Properties&} Writer::properties () const
Returns a vector of previously declared properties; these are the
result of calls to the @code{property()} function.
@end deftypefn

@c -------------------------------------------------------------------------
@node RawData,  , Writer, Library
@section Gto::RawDataReader/Gto::RawDataWriter classes

These classes provide a quick method of reading the contents of a GTO
file into memory for basic editing. The RawDataReader and
RawDataWriter both use the same very primitive data structure that can
be found in the RawData.h file. For examples of use, see
@command{gtomerge} and @command{gtofilter} source code.

The RawData class shows how to both read and write using the supplied
classes. In addition the reader subclass shows how to convert string
data. 

@c -------------------------------------------------------------------------
@c -------------------------------------------------------------------------
@node Module, Utilities, Library, Top
@chapter Python Module

The @code{gto} module implements a reader/writer library for the Python
language. The module is implemented on top of the C++ reader and writer
classes. The API is similar to the C++ API, but takes advantage of Python's
dynamic typing to ``simplify'' the design.  The Python module also implements a
significant number of safety checks not present in the C++ library, making it
an ideal way of exploring the Gto file format.

@menu
* PyReader::      Read GTO files
* PyWriter::      Write GTO files
* PyStructs::     Classes used by gto.Reader
@end menu

@c -------------------------------------------------------------------------
@node PyReader, PyWriter, Module, Module
@section gto.Reader

The Reader class is designed as a fill-in-the-blank API much like the
C++ library. The user of the class derives from it; the base class
defines a number of functions which you override to pass data to the
derived class and receive data from it.

As the file is read, the Reader class will call specific functions in
itself to declare objects in the file. The derived class is handed
data or asked to return whether or not it is interested in specific
properties in the file.

The biggest difference from the C++ Reader class is that the @code{data()} method of
the C++ class, which returns allocated memory for the library to read data
into, cannot be overloaded in Python.  Instead, the @code{dataRead()} method of the
Python gto.Reader class is handed pre-allocated Python objects containing the
data.

@deftypefn {Constructor} {@var{status}} gto.Reader (@var{mode})
Create a new gto.Reader instance.  Possible values for @var{mode}:

@table @strong
@item gto.Reader.NONE
The reader will be used in its standard @emph{streaming} mode. The
reader will attempt to read all the data in the file. This is the
default value (or 0).

@item gto.Reader.HEADERONLY
The reader will stop once it has read the header sections of the GTO file. 

@item gto.Reader.RANDOMACCESS
The reader will read the header sections but not the data, however, it
will initialize for use of the @code{gto.Reader.accessObject()} method.

@item gto.Reader.BINARYONLY
The reader will only accept binary GTO files.

@item gto.Reader.TEXTONLY
The reader will only accept text GTO files.
@end table

@end deftypefn

@deftypefn {Method} {} gto.Reader.open (@var{filename})
Opens and reads the GTO file @var{filename}. The function will raise a Python
exception if the file cannot be opened.
@end deftypefn

@deftypefn {Method} {@var{wants}} gto.Reader.object (@var{name}, @var{protocol}, @var{protocolVersion}, @var{objectInfo})
This function is called by the base class to declare an object in the GTO file.
The return value @var{wants} should evaluate to True or False, indicating
whether or not the base class should read the object data. @var{name} and
@var{protocol} are strings declaring name and protocol of the object,
@var{protocolVersion} is an integer. @var{objectInfo} is an instance of a 
generic class which contains the same information as the Gto::ObjectInfo 
C++ struct.
@end deftypefn

@deftypefn {Method} {@var{wants}} gto.Reader.component (@var{name}, @var{interpretation}, @var{componentInfo})
This function is called by the base class to declare a component in the GTO
file. The return value @var{wants} should evaluate to True or False, indicating
whether or not the base class should read the component data.  @var{name} is a
string declaring the component name. @var{componentInfo} is an instance of
a generic class which contains the same information as the Gto::ComponentInfo 
C++ struct.
@end deftypefn

@deftypefn {Method} {@var{wants}} gto.Reader.property (@var{name}, @var{interpretation}, @var{propertyInfo})
This function is called by the base class to declare a property in the GTO
file. The return value @var{wants} should evaluate to True or False, indicating
whether or not the base class should read the property data.  @var{name} is a
string declaring the full property name. @var{propertyInfo} is an instance of a
generic class which contains the same information as the Gto::PropertyInfo 
C++ struct.
@end deftypefn

@deftypefn {Method} {} gto.Reader.dataRead (@var{name}, @var{data}, @var{propertyInfo})
If a property has been requested, the dataRead() function will eventually be
called by the base class with the actual data in the file. The @var{name} is
the name of a property, @var{data} is a tuple containing the property data,
@var{propertyInfo} is an instance of a generic class which contains the same 
information as the Gto::PropertyInfo C++ struct.
@end deftypefn

@deftypefn {Method} {} gto.Reader.stringFromID (@var{id})
Returns the stringTable entry for the given string table id.  Since the
Python gto module returns strings directly, it is unlikely that you'll need
to use this.
@end deftypefn

@deftypefn {Method} {} gto.Reader.stringTable ()
Returns the entire stringTable as a list of strings.
@end deftypefn

@deftypefn {Method} {} gto.Reader.isSwapped ()
Returns True if the file on disk is not in the machine's native byte order.
@end deftypefn

@deftypefn {Method} {} gto.Reader.objects ()
Returns a list of the gto.ObjectInfo instances for all the objects in the
file.  This method is only available if the file was opened with
gto.Reader.RANDOMACCESS.  Usable at any time after the constructor is called.
@end deftypefn

@deftypefn {Method} {} gto.Reader.components ()
Returns a list of the gto.ComponentInfo instances for all the components in the
file.  This method is only available if the file was opened with
gto.Reader.RANDOMACCESS.  Usable at any time after the constructor is called.
@end deftypefn

@deftypefn {Method} {} gto.Reader.properties ()
Returns a list of the gto.PropertyInfo instances for all the properties in the
file.  This method is only available if the file was opened with
gto.Reader.RANDOMACCESS.  Usable at any time after the constructor is called.
@end deftypefn

@deftypefn {Method} {} gto.Reader.accessObject (@var{objInfo})
Given an instance of gto.ObjectInfo (obtained via gto.Reader.objects(), 
gto.Reader.components(), or gto.Reader.properties()), tells the reader
to access that object directly.  This will cause the gto.Reader.object(),
gto.Reader.component(), and gto.Reader.dataRead() methods to be called
with the information from the given object.
@end deftypefn


@c -------------------------------------------------------------------------
@node PyWriter, PyStructs, PyReader, Module
@section gto.Writer

@deftypefn {Constructor} {} gto.Writer ( )
Creates a new writer instance, no arguments needed.
@end deftypefn

@deftypefn {Method} {} gto.Writer.open (@var{filename}, @var{mode})
Open the file. The Writer will attempt to open file 
@var{filename}.  If the file is not writable for whatever reason, the
function will raise a Python exception.  The @var{mode} argument can 
be @code{BINARYGTO}, @code{COMPRESSEDGTO} (the default) or @code{TEXTGTO}.
@end deftypefn

@deftypefn {Method} {} gto.Writer.close ( )
Close the file and clean up temporary data.  Because of Python's
garbage-collection, you can never be sure when a class's destructor will be
called.  Therefore, it is @emph{highly} recommended that you call this method to
close your file when it's done writing.  You have been warned.
@end deftypefn

@deftypefn {Method} {} gto.Writer.beginObject (@var{name}, @var{protocol}, @var{version}) 
Declares an object. Its components and properties must be declared
before endObject() is called. The @var{name} is the name of the object
as it will appear in the gto file. The @var{protocol} is the protocol
string indicating how the object data will be interpreted and the
@var{version} number indicates the protocol version. The Writer class
does not verify that the data output conforms to the protocol.
@end deftypefn

@deftypefn {Method} {} gto.Writer.beginComponent (@var{name}, @var{interpretation}, @var{transposed}) 
Declares a component. The component properties must be declared before
a call to endComponent(). The @var{name} is the name of the component
as it will appear in the gto file. The @var{transposed} flag is
optional and indicates whether or not the component property data
should be output transposed or one property at a time (the default).
@end deftypefn

@deftypefn {Method} {} gto.Writer.property (@var{name}, @var{type}, @var{numElements}, @var{partsPerElement}, @var{interpretation})
Declare a property. The @var{name} is the name of the property as it
appears in the gto file. The @var{type} is one of gto.DOUBLE,
gto.FLOAT, gto.INT, gto.STRING, gto.BYTE, gto.HALF (@emph{Not implemented}), or
gto.SHORT. @var{numElements} indicates the number of elements of size
@var{partsPerElement} that will be in the property data. So for
example, if the property is declared as a gto.FLOAT of
with @var{partsPerElement} of 3 and there 10 of them, then the writer
will expect a sequence of 30 floats when the propertyData is finally
passed to it.
@end deftypefn

@deftypefn {Method} {} gto.Writer.endComponent ()
Closes the declaration of a component started by beginComponent().
@end deftypefn

@deftypefn {Method} {} gto.Writer.endObject ()
Closes the declaration of an object started by beginObject().
@end deftypefn

@deftypefn {Method} {} gto.Writer.intern (@var{string})
Declares a string to the Writer for inclusion in the file string table. When
writing properties of type gto.String, its necessary to call this function for
each string in the property data before the beginData() is called.  The Python
version of intern() can accept individual strings, as well as lists or tuples
of strings.
@end deftypefn

@deftypefn {Method} {int} gto.Writer.lookup (@var{string})
Retrieve the identifier of the previously interned string.  Valid only after
beginData() has been called.
@end deftypefn

@deftypefn {Method} {} gto.Writer.beginData ()
Begins data declaration to the Writer class. Only calls to lookup(),
propertyData(), and endData() are legal after beginData() is called.
@end deftypefn

@deftypefn {Method} {} gto.Writer.propertyData (@var{data})

The propertyData() function must get exactly @emph{one} parameter.  That
parameter can be any of the following:

@itemize 
@item
A single int, float, string, etc.
@item
An instance of mat3, vec3, mat4, vec4, or quat
(@url{http://cgkit.sourceforge.net/}).  DO NOT explicitly cast mat3 or mat4 into a
tuple or list: @code{tuple(mat4(1))}.  It will be silently transposed (a bug in the
cgtypes code?).  ADDING it to a tuple or list is fine:  @code{(mat4(1),)}
@item
A tuple or list of any combination of the above that makes sense.
@end itemize

Tuples and lists are flattened out before they are written.  As long as the
number of atoms is equal to size x width, it'll work.  Calls to propertyData()
must appear in the same order as declared with the property() method.

@end deftypefn

@deftypefn {Method} {void} gto.Writer.endData ()
Closes the definition of data started by beginData() and finishes
writing the gto file.  Does @emph{not} actually close the file--use the close()
method for that.
@end deftypefn

@c -------------------------------------------------------------------------
@node PyStructs,  , PyWriter, Module
@section Classes used by gto.Reader

Note that as of the 3.0 release, these classes will contain the actual strings
rather than string table IDs.

@deftp {Class} gto.ObjectInfo
This class emulates the Gto::ObjectInfo struct from the C++ Gto library.  It is
passed by the Python gto.Reader class to your derived @code{object()} method. 
The only methods implemented are @code{__getattr__} and @code{__repr__}.  
Available attributes are:

@itemize
@item @code{name} - String
@item @code{protocolName} - String
@item @code{protocolVersion}  - Integer 
@item @code{numComponents} - Integer
@item @code{pad} - Integer
@end itemize

@end deftp

@deftp {Class} gto.ComponentInfo
This class emulates the Gto::ComponentInfo struct from the C++ Gto library.  It
is passed by the Python gto.Reader class to your derived @code{component()}
method.  The only methods implemented are @code{__getattr__} and
@code{__repr__}. Available attributes are:

@itemize
@item @code{name} - String
@item @code{numProperties} - Integer
@item @code{flags} - Integer
@item @code{interpretation} - String
@item @code{pad} - Integer
@item @code{object} - Instance of gto.ObjectInfo
@end itemize

@end deftp

@deftp {Class} gto.PropertyInfo
This class emulates the Gto::PropertyInfo struct from the C++ Gto library.  It
is passed by the Python gto.Reader class to your derived @code{property()} and
@code{dataRead()} methods.  The only methods implemented are @code{__getattr__}
and @code{__repr__}.  Available attributes are:

@itemize
@item @code{name} - String
@item @code{size} - Integer
@item @code{type} - Integer
@item @code{width} - Integer
@item @code{interpretation} - String
@item @code{pad} - Integer
@item @code{component} - Instance of gto.ComponentInfo
@end itemize

@end deftp

@c -------------------------------------------------------------------------
@c -------------------------------------------------------------------------

@node Utilities, Changes, Module, Top
@chapter Utilities

@menu
Command line tools

* gtoinfo::      Find out what's in a gto file.
* gtofilter::    Filter properties out of a gto file.
* gtomerge::     Merge the contents of multiple gto files into one.
* gto2obj::      Wavefront .obj translator.
* gtoimage::     Make an image into a GTO object.
* RiGtoRibOut::  Convert GTO files to ASCII RIB.

Plug-ins:

* gtoIO::               Maya scene file I/O.
* RiGtoPlugin::         Render gto files directly.

@end menu

@c -------------------------------------------------------------------------

@node gtoinfo, gtofilter, Utilities, Utilities
@section The @command{gtoinfo} Utility

Usage: @command{gtoinfo [OPTIONS] @var{infile.gto}}

Options:

@table @option
@item -a/-all
Output property data and header.

@item -d/--dump
Output property data (no header data is emitted).

@item -l/--line
Output property data one item per line. Can be used with either
@option{-d} or @option{-s}.

@item -h/--header
Output header data.

@item -s/--strings
Output sting table data.

@item -n/--numeric-strings
Output sting data as the raw string id instead of the string itself.

@item -i/--interpretation-strings
Output interpretation string data for components and properties if it exists.

@item -r/--readall
Force reading of the enitre gto file even if only the header is being
output.

@item -f/--filter expression
Only output information for properties who's long name
(object.component.propname) matches the shell-like
@emph{expression}. @ref{gtofilter} for examples of filter
expressions. This option is similar to @command{gtofilter}
@option{--include} option.

@item --help
Output usage message.

@end table

@command{gtoinfo} outputs the part of all of the contents of a gto
file in human readable form. Its invaluable for debugging or just
getting a quick understanding of what a gto file contains.


@c -------------------------------------------------------------------------

@node gtofilter, gtomerge, gtoinfo, Utilities
@section The @command{gtofilter} Utility

Usage: @samp{gtofilter [OPTIONS] -o @var{out.gto} @var{in.gto}}

Options:

@table @option

@item -v
Set verbose output. Whenever a pattern matches gtofilter will inform
you.

@item -ee/--exclude
Regular expression which will be used to exclude properties.

@item -ie/--include
Regular expression which will be used to include properties.

@item -regex
Use POSIX regular expression syntax.

@item -glob
Use shell-like regular expression (fnmatch). This is the default.

@item -t
Output text GTO file.

@item -nc
Output uncompressed binary GTO file.

@item -o @var{out.gto}
Output .gto file

@end table

@command{gtofilter} can be used to remove objects, components, and
properties from a gto file. You supply an include shell-like
expression and/or an exclude shell-like expression. (The pattern
matching is done using the fnmatch() function -- see the man page for
details.) 

The patterns match each full property name. So for example a cube
might have these properties:

@example 
    cube.points.position 
    cube.elements.type 
    cube.elements.size
    cube.indices.vertex 
    cube.indices.st
    cube.indices.normal
    cube.normals.normal
    cube.mappings.st
    cube.smoothing.method
    cube.object.globalMatrix
    cube.object.parent
@end example

Using the @option{--exclude} option, you can remove the object
component by doing this:

@example
    gtofilter --exclude "*.object.*" -o out.gto cube.gto
@end example

or if you wanted to pass through only the positions:

@example
    gtofilter --include "*.*.positions" -o out.gto cube.gto

        -or-

    gtofilter --include "*positions" -o out.gto cube.gto
@end example

@c -------------------------------------------------------------------------

@node gtomerge, gto2obj, gtofilter, Utilities
@section The @command{gtomerge} Utility

Usage: @samp{gtomerge -o @var{outfile.gto} @var{infile1.gto} @var{infile2.gto} ...}

Options:

@table @option

@item -o outfile.gto
The resulting merged file to output.

@item -t
Ouput text GTO file.

@item -nc
Ouput uncompressed binary GTO file.

@end table

@command{gtomerge} takes a number of .gto input files and merges them
into a single output .gto file. This is done by first creating output
geometry that is identical to the first input file and then adding
only those properties that are not already defined from subsequent gto
files. The order of input files determines what will be in the final
output file.

For @strong{difference} files, you can use gtomerge to reconstruct a
final file like this:

@example
    gtomerge -o out.gto difference.gto reference.gto
@end example

@c -------------------------------------------------------------------------

@node gto2obj, gtoimage, gtomerge, Utilities
@section The @command{gto2obj} Utility

Usage: @samp{gto2obj [OPTIONS] @var{infile} @var{outfile}}

Options:

@table @option
@item -o NAME
When outputing GTO files, the name of an object in the GTO file to
output. If not specified, the translator will output the first
polygon, or subdivision surface it finds.

@item -c
When outputing GTO files, this option will force the protocol to be
"catmull-clark".

@item -l
When outputing GTO files, this option will force the protocol to be
"loop".

@item -t
Ouput text GTO file.

@item -nc
Ouput uncompressed binary GTO file.
@end table


@command{gto2obj} takes either an input GTO file or Wavefront .obj
file and outputs the other file type.

@example
    gto2obj in.obj out.gto
    gto2obj in.gto out.obj
    gto2obj -c in.obj out.gto ## output obj as subdivision surface
@end example

@c -------------------------------------------------------------------------

@node gtoimage, RiGtoRibOut, gto2obj, Utilities
@section The @command{gtoimage} Utility

Usage: @samp{gtoimage @var{infile} @var{outfile}}

@table @option
@item -t
Ouput text GTO file.

@item -nc
Ouput uncompressed binary GTO file.
@end table

@command{gtoimage} reads a TIFF file and converts it into a GTO file
containing one image object. 32 bit floating point images, 16 bit and
8 bit integral images are directly converted. @command{gtoimage}
expects the image to be two dimensional with three or four channels
where the fourth channel is an optional alpha value. The output object
conforms to the @strong{image} protocol. @xref{Image}.

You can use @command{gtomerge} to merge the image object into another
GTO file. @xref{gtomerge}.

It is highly recommend that the resulting output GTO file be written
with compression or gzipped to reduce its size. Gzipped GTO files can
be read directly by the supplied readers.

@c -------------------------------------------------------------------------

@node RiGtoRibOut, gtoIO, gtoimage, Utilities
@section The @command{RiGtoRibOut} Utility

The @command{RiGtoRibOut} command is useful for:

@itemize  

@item
It can be used as a debugging tool for the RiGtoPlugin RenderMan plugin.

@item
It can be used as a drop-in replacement for RiGtoPlugin, for RIB renderers that
do not support @code{Procedural DynamicLoad}, but that @emph{do} support
@code{Procedural RunProgram}.  Note that this is substantially slower than
using RiGtoPlugin, as all data needs to be translated to ASCII and back.  It
does have the one space-saving advantage of not needing to save ASCII RIB on
disk.

@item
It could be used to generate RIB files that are read with @code{ReadArchive}. 
This is not recommended, as it negates all the advantages of using GTO in the
first place.  But if nothing else works, this should.

@end itemize

The command-line parameters are the same as the @var{CONFIG_STRING} for 
RiGtoPlugin.  @xref{RiGtoPlugin}.



@c -------------------------------------------------------------------------

@node gtoIO, RiGtoPlugin, RiGtoRibOut, Utilities
@section The @command{gtoIO.so} Maya Plug-In

The Maya plugin comes in two parts: the C++ plugin which implements a
Maya scene translator and an accompanying MEL script which implements
the user interface.

The plugin handles export of NURBS surfaces (but not trim curves),
polygonal geometry (which can be written as sub-division surfaces), 
and generic transforms.  A Maya particle export tool is in the works.
Additional user defined attributes can be emitted into the GTO file.

The plugin can import everything that it exports and also particle
GTO files generated by other applications.

@subsection BUGS

The internal perfomance of Maya has changed between the 4.x and 5.0
versions. In Maya 5.0, the Maya API is @emph{extremely} slow when
importing polygonal normals. Importing of normals is disabled in Maya
5.0.

@c -------------------------------------------------------------------------

@node RiGtoPlugin,  , gtoIO, Utilities
@section The @command{RiGtoPlugin} RenderMan plugin

Here you will find information on using the GTO RenderMan plugin.  The
documentation is complete enough to get started with, but should be considered
a work in progress.

@menu

* RIB Instantiation::           How to call the plugin from a RIB file
* Config String Syntax::        Syntax of the Config String
* On-List/Off-List Syntax::     How to hide/show parts of a GTO file
* Cache Management::            Controlling RiGto's cache
* Environment Variables::       Environment Variables affecting RiGtoPlugin
* Usage Strategy::              How to use the Plugin
* Miscellaneous RenderMan Stuff:: Additional data that might be useful

@end menu

@c -------------------------------------------------------------------------

@node RIB Instantiation, Config String Syntax, RiGtoPlugin, RiGtoPlugin
@subsection RIB Instantiation

The plugin is instantiated in a RIB Stream using the standard
DynamicLoad procedural mechanism, like so:

@example
Procedural "DynamicLoad" [ "RiGtoPlugin.so" "@var{CONFIG_STRING}" ] [ @var{Bounding Box} ]
@end example


If a bounding box is not known, the infinite box may be used:

@example 
Procedural "DynamicLoad" [ "RiGtoPlugin.so" "@var{CONFIG_STRING}" ] [ -1e6 1e6 -1e6 1e6 -1e6 1e6 ]
@end example


@c -------------------------------------------------------------------------

@node Config String Syntax, On-List/Off-List Syntax, RIB Instantiation, RiGtoPlugin
@subsection Config String Syntax

The configuration string passed into RiGtoPlugin consists
of a variable number of space-separated tokens. They are, 
in order:

@enumerate
@item
Reference Pose GTO File Name
@item
Shutter Open GTO File Name (optional)
@item
Shutter Close GTO File Name (optional)
@item
Primary On List (optional)
@item
Primary Off List (optional)
@item
Secondary On List (optional)
@item
Secondary Off List (optional)
@end enumerate

As shown, the only necessary element is the reference GTO file.
For objects which do not have movement and do not require on lists
or off lists, this is completely sufficient.

The logic behind the geometry instantiation mechanism is as follows:

@itemize @bullet
@item
Read Reference GTO file
The plugin reads all of the geometry in the reference GTO file. As a
starting point, the shutter open and close geometry is set equal to the
reference geometry. 

@item
If requested, read Shutter Open GTO file
The plugin then reads any geometry from the Shutter Open file that matches the
name and geometry type of geometry that has already been read from the
reference file - this geometry is stored as both the shutter open AND close
geometry.

@item
If requested, read Shutter Close GTO file
The plugin then reads any geometry from the Shutter Close file that matches the
name and geometry type of geometry that has already been read from the
reference file - this geometry is stored as the shutter close geometry

@item
Instantiate Geometry:
For any piece of geometry that appears in BOTH on-lists and does 
not appear in EITHER off-lists, the plugin calls the appropriate RIB functions
to create the requested geometry.

@end itemize

@c -------------------------------------------------------------------------

@node On-List/Off-List Syntax, Cache Management, Config String Syntax, RiGtoPlugin
@subsection On-List/Off-List Syntax

The syntax of the on-lists and off-lists is as follows:

@code{NULL} is a special on-list/off-list which is interpreted as
@emph{all on} or @emph{none off}.

Otherwise, the on-lists and off-lists are essentially shell-like regular
expressions.  The following rules apply:

@itemize
@item 
The @code{*} character matches any number of characters
@item 
The @code{?} character matches any single of character
@item 
Bracket expressions @code{[]} are supported. (See @code{man 7 regex})
@item 
Multiple patterns can be strung together with the @code{|} character.
@item 
The pattern must match the @emph{whole} object name.  Thus, the pattern 
"@code{*Sphere1}" will match the object @code{nurbsSphere1} but @emph{not}
@code{nurbsSphere1Shape}.  This is a very common "gotcha".

@end itemize

As an example, suppose you wanted to turn off all of the geometry
named @code{LeftLeg*Shape*} and @code{RightLeg*Shape*} in a render - you would 
create an off-list that looked like:

@example
"LeftLeg*Shape*|RightLeg*Shape*"
@end example



@c -------------------------------------------------------------------------

@node Cache Management, Environment Variables, On-List/Off-List Syntax, RiGtoPlugin
@subsection Cache Management

By default, RiGtoPlugin maintains an internal cache 
of all of the file sets it has read. The cache is keyed
off of Ref-Open-Close filename triplets.  The reason for
this is to facilitate easy material assignment, which will
be discussed in greater detail below in the "Strategy"
section.

In situations where memory is precious and the renderer
needs as much memory as it can get, it may be advantageous
to force RiGtoPlugin to discard its cached file sets. There
is special syntax to facilitate this.

@itemize @bullet
@item
To erase everything in RiGtoPlugin's cache:

@example
Procedural "DynamicLoad" [ "RiGtoPlugin.so" "__FLUSH__" ] [ @var{Bounding Box} ]
@end example

@item
To erase the cache associated with a given file triplet:
(Using REF.gto, OPEN.gto and CLOSE.gto as standins for whatever
files were actually passed in)

@example
Procedural "DynamicLoad" [ "RiGtoPlugin.so" "@var{REF}.gto @var{OPEN}.gto @var{CLOSE}.gto __FLUSH__" ] [ @var{Bounding Box} ]
@end example

@end itemize

There is also an environment variable, @code{TWK_RI_GTO_NO_CACHE}, which if
defined and set to anything other than "0", "FALSE", "False" or "false", will
cause caching to be disabled entirely.


@c -------------------------------------------------------------------------

@node Environment Variables, Usage Strategy, Cache Management, RiGtoPlugin
@subsection Environment Variables

@defvr {Environment Variable} @code{TWK_RI_GTO_NO_SUBDS}
If this environment variable is defined and set to anything 
except "0", "FALSE", "False", or "false", RiGtoPlugin will
treat all catmull-clark subdivision surfaces read from a GTO
file as polygons instead. 
@end defvr

@defvr {Environment Variable} @code{TWK_RI_GTO_NO_CACHE}
If this environment variable is defined and set to anything 
except "0", "FALSE", "False", or "false", RiGtoPlugin will
disable all caching of geometry data to save memory.
@end defvr

@c -------------------------------------------------------------------------

@node Usage Strategy, Miscellaneous RenderMan Stuff, Environment Variables, RiGtoPlugin
@subsection Usage Strategy

The RiGtoPlugin was designed with a particular data structure in
mind. Used ideally, there would be a GTO file consisting of all of
the geometry corresponding to a particular high-level creature or
set in the scene. All of the surfaces corresponding to a hippo or
a giraffe or a cyborg-monkey would be in a single GTO file. The
animation data for this geometry would be contained in light-weight
GTO files that contain only points that have moved and transformation
matrices that have moved. The RiGtoPlugin only reads points and 
matrices from the Shutter-Open and Shutter-Close file, facilitating
very light-weight "difference" files for animation data.

Because all of the geometry in a creature will have different 
materials assigned to it, on-lists and off-lists can be used to
separate out only the geometry that shares a particular material.

Suppose we have a creature consisting of many surfaces but only
three different materials - skinMtl, eyeMtl and hairMtl. The
parts of the model have been named intelligently (for this example)
such that the skin parts all have names like Skin*Shape*, the eye
parts all have names like Eye*Shape*, and the hair parts all have
names like Hair*Shape*. Then, the RIB for declaring this creature
with material assignments might look like this:

@example
AttributeBegin
Surface "skinShader" [ @var{shader param settings} ]
Procedural "DynamicLoad" [ "RiGtoPlugin.so" "thing.ref.gto thing.0013.open.gto thing.0013.close.gto Skin*Shape*" ][-1e6 1e6 -1e6 1e6 -1e6 1e6]
AttributeEnd

AttributeBegin
Surface "hairShader" [ @var{shader param settings} ]
Procedural "DynamicLoad" [ "RiGtoPlugin.so" "thing.ref.gto thing.0013.open.gto thing.0013.close.gto Hair*Shape*" ][-1e6 1e6 -1e6 1e6 -1e6 1e6]
AttributeEnd

AttributeBegin
Surface "eyeShader" [ @var{shader param settings} ]
Procedural "DynamicLoad" [ "RiGtoPlugin.so" "thing.ref.gto thing.0013.open.gto thing.0013.close.gto Eye*Shape*" ][-1e6 1e6 -1e6 1e6 -1e6 1e6]
AttributeEnd
@end example

Because of RiGtoPlugin's cache mechanism, the geometry associated with
the file-set thing.*.gto is only read and interpreted one time - the
on-lists control which parts of the geometry are instantiated at which
times. To nuke the cache of these files (if memory is important), you
would use the syntax:

@example
Procedural "DynamicLoad" [ "RiGtoPlugin.so" "thing.ref.gto thing.0013.open.gto thing.0013.close.gto __FLUSH__" ][-1e6 1e6 -1e6 1e6 -1e6 1e6]
@end example


@c -------------------------------------------------------------------------

@node Miscellaneous RenderMan Stuff,  , Usage Strategy, RiGtoPlugin
@subsection Miscellaneous RenderMan Stuff


RiGtoPlugin stores some useful data in attributes that
can be used by shaders if desired.

@defvr {Shader parameter} Pref 
On ALL geometry RiGtoPlugin creates "varying point Pref" as
part of its geometry declaration. This data can be accessed by
simply putting "varying point Pref" in your shader parameters. The
position of the model in the reference GTO file is always used for
this parameter value.
@end defvr

@defvr {RIB Attribute} Name
RiGtoPlugin always places the name of the geometry, as retrieved from
the GTO file, in an attribute that may be queried. It is exactly as
if the following line of RIB were declared before the geometry were
instantiated:

@example
Attribute "identifier" "name" ["whatever my name is"]
@end example

@end defvr

@defvr {RIB Attribute} RefToWorld matrix
RiGtoPlugin places the transformation matrix @var{objectToWorld} from the
reference model into a user attribute called @code{refToWorld}. To prevent
this attribute from being munged by the current transformation matrix,
it is cast as a float[16] instead of a matrix. It is equivalent to
this line of RIB:

@example
Attribute "user" "float refToWorld[16]" [ @var{the matrix values} ]
@end example

@end defvr






@c -------------------------------------------------------------------------

@node Changes, Reference, Utilities, Top
@appendix Description of Changes


@itemize @bullet

@item Version 3.4

@itemize @bullet

@item
The GTO license terms have been changed: the code is still covered by
the LGPL, but with additional @strong{exceptions} similar to those used
by the FLTK library. These exceptions make it easier to use GTO in
commercial projects.

@item
The library no longer attempts to be source code compatible with older
Microsoft compilers. Some functions may throw on error.

@item
Bug fixes to the C++ Gto::Writer class for output of text GTO files.

@item
Run-time error checking of the Gto::Writer API. The class will complain
if the API is used in a undocumented manner. It may throw an
exception. 

@item
The GTO source code distribution now comes with Maya and Houdini plugins
for cached deforming geometry and particle export and display.

@end itemize

@item Version 3.2

@itemize @bullet
@item
Human readable plain text version of GTO. Some readers may not function if 
they assume that the property size is known when the property() virtual 
function is called. The property size is only really known when the data()
virtual function is called. Only version 3.2 GTO readers can read the
text version.

@item
Animation curves are now stored per-object using the animation
protocol.

@item
Bug fixes to Gto::Reader class to allow reuse of existing class with a
newly opened file.

@end itemize

@item Version 3.1

@itemize @bullet

@item
RenderMan plug-in documentation added.

@end itemize

@item Version 3.0

@itemize @bullet

@item
An interpretation string has been added to the property header.

@item
An additional uint32 has been added as padding to the object, component,
and property headers for future expansion slop.

@item
A section on interpretation strings has been added to the
documentation and to the reader/writer classes.

@item
Added a type reference to the documentation.

@end itemize

@item Version 2.1

@itemize @bullet

@item
@command{gtofilter} was changed to optionaly accept POSIX style
regular expressions in addition to shell-like ``glob'' expressions.

@item 
The C++ writer class now defaults to writing compressed files when the
open() function is called. A second bool argument can be passed to it
to prevent the compression.

@item 
The proposed texture assignment protocol (from version 2.0.4) has been
rejected.

@item
A new protocol ``channel'' is introduced for assigning mapped surface
varying data on geometry. An arbitrary number of texture maps may be
assigned to the geometry. @xref{Channels}.

@item
The material protocol has been fleshed out. @xref{Material}.

@item
The polygon protocol was missing the definition of the optional
@strong{mappings} component. @xref{Polygonal Surfaces}.

@end itemize


@item Version 2.0.5
Bug fix version. Repaired problems with the configuration
scripts. Missing headers.

@item Version 2.0.4
Bug fix version. Some configuration problems solved.

@item Version 2.0
File headers changed. The format is not compatible with 1.0.

@item Version 1.0
@end itemize


@c -------------------------------------------------------------------------

@node Reference,  , Changes, Top
@appendix Reference

@heading Properties
@printindex vr

@heading Functions
@printindex fn

@heading Types
@printindex tp

@bye
